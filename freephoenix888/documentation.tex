\documentclass{article}
\usepackage[utf8]{inputenc} % For Unicode characters
\usepackage[T2A]{fontenc}    % Font encoding for Cyrillic characters
\usepackage{graphicx}	     % Required for inserting images
\usepackage{titletoc}
\usepackage{listings}
\usepackage{titling}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{lipsum} % Для генерации случайного текста
% Syntax Highlighting
\usepackage{xcolor}
\usepackage{listings}
\usepackage{listingsutf8}

\lstdefinelanguage{TypeScript}{
  keywords=[1]{break, case, catch, continue, debugger, default, delete, do,
      else, false, finally, for, function, if, in, instanceof, new, null,
      return,
      switch, this, throw, true, try, typeof, var, void, while, with},
  keywordstyle=[1]\color{blue}\bfseries,
  keywords=[2]{abstract, as, constructor, declare, enum, export, extends, from,
      get, implements, import, interface, let, module, private, protected,
      public,
      set, static, yield, in},
  keywordstyle=[2]\color{teal}\bfseries,
  identifierstyle=\color{black},
  commentstyle=\color{green!40!black},
  stringstyle=\color{purple},
  sensitive=true
}

\lstset{
  language=TypeScript,
  extendedchars=true,
  basicstyle=\small\ttfamily,
  showstringspaces=false,
  showspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=5pt,
  tabsize=2,
  breaklines=true,
  showtabs=false,
  xleftmargin=2em,  % Adjust the value according to your indentation style
}

\renewcommand{\contentsname}{Содержание} % Change the name of the table of contents

\title{Deep Foundation}
\author{FreePhoenix888}
\date{November 2023}

\begin{document}

\maketitle

\newpage % новая страница

\section{Вступление}
\subsection{Аннотация}

Данный текст представляет собой описание основных концепций и структур в рамках
архитектуры Deep. Deep представляет собой систему, организованную вокруг
понятий связей, пакетов и обработчиков.

\begin{enumerate}
  \item \textbf{Связи:}
        \begin{itemize}
          \item Связи могут иметь различные атрибуты, такие как идентификатор,
                тип, начало, конец и значение.
          \item Тип, начало и конец связи являются связями, что создает
                структуру, где связи могут указывать друг на друга.
          \item Приведены примеры различных типов связей, таких как Message,
                Conversation, Reply и др.
        \end{itemize}

  \item \textbf{Связи-типы:}
        \begin{itemize}
          \item Любая связь может использоваться как тип для создания другой
                связи
          \item Если связь является точкой (без начала и конца) - экземпляр
                такой связи тоже будет точкой
          \item Если связь ведёт от связи А к связи Б, то экземпляр этой связи
                должен вести от экземпляра связи А к экземпляру связи Б
          \item Если нужно что бы экземпляр связи мог быть связан с любой
                связью,
                то нужно использовать встроенный тип \hyperlink{any.def}{Any}
        \end{itemize}

  \item \textbf{Пакеты:}
        \begin{itemize}
          \item Существует встроенный в Deep тип Contain, обозначающий
                принадлежность связей к определенному пакету.
          \item Пакеты не обязательно содержат связи напрямую; они могут
                указывать на связи из других пакетов. В таком случае пакет
                становится зависимым от другого пакета
        \end{itemize}

  \item \textbf{Обработчики:}
        \begin{itemize}
          \item Виды серверных обработчиков: обработчики базы данных,
                обработчики веб-маршрута и порта
          \item Серверные обработчики баз данных и событий над связями могут
                быть синхронными (выполняются в рамках транзакции и внутри базы
                данных) и
                асинхронными (выполняются в Docker'е, за пределами транзакции
                внутри базы
                данных)
          \item Клиентские обработчики предоставляют возможность показывать
                визуальный графический интерфейс для связи в \hyperlink{DeepCase.Def}{DeepCase}
        \end{itemize}

  \item \textbf{\hyperlink{DeepCase.Def}{DeepCase}:}
        \begin{itemize}
          \item \hyperlink{DeepCase.Def}{DeepCase} это графический визуальный интерфейс Deep
          \item Визуализация конкретных связей реализована при помощи
                клиентских обработчиков
          \item \hyperlink{DeepCase.Def}{DeepCase} позволяет взаимодействовать со связями: вставлять,
                обновлять, удалять, просматривать, делать выборку связей,
                путешествовать по ним, используя traveller, и ещё множество
                возможностей
          \item \hyperlink{DeepCase.Def}{DeepCase} это npm пакет, который позволяет встраивать его
                компоненты, включая отдельные клиентские обработчики, используя
                ClientHandler
                компонент в любой проект, использующий npm пакет React
        \end{itemize}

  \item \textbf{Дип клиент:}
        \begin{itemize}
          \item Дип Клиент для программного взаимодействия с Deep в среде
                JavaScript, позволяет вставлять, получать, обновлять и удалять
                связи.
        \end{itemize}

  \item \textbf{Таблицы:}
        \begin{itemize}
          \item Deep использует использует различные таблицы, такие как links
                (для хранения связей) и numbers, strings, objects (для хранения
                значений
                привязанных к связям)
        \end{itemize}
\end{enumerate}

Приведены примеры использования Дип Клиента для различных операций, таких как
вставка связей различных типов, получение данных, обновление и удаление.

% Add a subsection heading to the table of contents
% \addtocontents{toc}{\protect\subsection{Содержание}}

% Table of contents
\tableofcontents

\section{Основная часть}

% Краткое описание
\subsection{Краткое описание}

\subsection{Основные концепты}

\begin{itemize}
  \item Связи
  \item Связи-типы
  \item Пакеты, содержащие связи (сам пакет тоже является связью)
  \item Обработчики событий
  \item Материализованный путь связей, деревья
  \item \hyperlink{DeepCase.Def}{DeepCase}
  \item Дип Клиент
  \item Таблицы
\end{itemize}

% Связи
\subsection{Связи}

\subsubsection{Описание}

\paragraph{Аттрибуты связи}

\begin{itemize}
  \item \texttt{id} (число)
  \item \texttt{Тип} (\texttt{type}) (число)
  \item Начало (\texttt{from}) (число)
  \item Конец (\texttt{to}) (число)
  \item Значение (строка/число/объект)
\end{itemize}

\paragraph{Практическое правило (Rule of thumb)}
Тип, начало, конец - являются связью. Связи указывают на связи. Таким образом,
любая связь может быть типом/началом/концом для другой связи.

\paragraph{Пример}

\begin{itemize}
  \item \texttt{Message (type: \hyperlink{type.def}{Type})}
  \item \texttt{Conversation(type: \hyperlink{type.def}{Type})}
  \item \texttt{Reply(type: \hyperlink{type.def}{Type}, from: Message, to:
          Conversation)}
  \item \texttt{UrgentMessage(type: Message)}
  \item \texttt{UrgentReply(type: Reply, from: UrgentMessage, to:
          Conversation)}
\end{itemize}

\subsection{Связи-типы}
\paragraph{Описание}
Любая связь может быть типом для вставки другой связи.
\paragraph{Сценарии использования связи как типа}
Если связь является точкой (без начала и конца) - экземпляр такой связи тоже
будет точкой
Если связь является связью между двумя определёнными типами - вы сможете
вставить связь только между связями этих определённых типов
Совет: если связь должна вести от/до неопределённого типа связи, то следует
использовать встроенный тип \hyperlink{any.def}{Any}
\paragraph{Примеры}
\subparagraph{Пример с связью точкой}
\begin{enumerate}
  \item Вставьте связь типа \hyperlink{type.def}{Type} без начала и конца
  \item Вставьте связь типа "Ваш тип" без начала и конца
\end{enumerate}
\subparagraph{Пример с связью между определёнными связями}
\begin{enumerate}
  \item Вставьте связь типа \hyperlink{type.def}{Type} от Package до User
  \item Вставьте связь вашего типа от экземпляра Package до экземпляра User
  \item Попробуйте вставить связь вашего типа от экземпляра не Package до
        экземпляра не User, и увидите ошибку
\end{enumerate}
\subparagraph{Пример с связью между Any и User}
\begin{enumerate}
  \item Вставьте связь типа \hyperlink{type.def}{Type} от Any до User
  \item Вставьте связь вашего типа от любой связи до экземпляра User и
        созерцайте, что начало вашей связи может быть любым
\end{enumerate}
\subparagraph{Пример с связью между Any и Any}
\begin{enumerate}
  \item Вставьте связь типа \hyperlink{type.def}{Type} от Any до Any
  \item Вставьте связь вашего типа от любой связи до любой связи и
        созерцайте, что начало и конец вашей связи может быть любым
\end{enumerate}
% Пакеты
\subsection{Пакеты}

В Deep есть встроенный тип \texttt{Contain}, который указывает на
принадлежность. Чаще всего он используется для того, чтобы пакет
\texttt{Contain} в себе определенные связи, необходимые для его работы.
Пакеты не обязательно содержат связи напрямую; они могут
указывать на связи из других пакетов. В таком случае пакет
становится зависимым от другого пакета

Пример создания связи, которая указывает на связь другого пакета и содержится в
нашем пакете:

\begin{lstlisting}
await deep.insert({
  type_id: await deep.id("@freephoenix888/dependency", "Dependency"),
  from_id: await deep.id("deep-memo", "Device"),
  to_id: await deep.id("deep-memo", "Device"),
  in: {
    data: [
      {
        type_id: await deep.id("@deep-foundation/core", "Contain"),
        from_id: await deep.id("MyPackageName"),
        string: {
          data: {
            value: `MyDependency`,
          },
        },
      },
    ],
  },
});
\end{lstlisting}

% Обработчики
\subsection{Обработчики}

\subsubsection{Виды обработчиков}
\begin{itemize}
  \item \textbf{Серверные обработчики баз данных и событий над связями}
  \item \textbf{Серверные обработчики веб маршрута и порта}
  \item \textbf{Клиентские обработчики}
\end{itemize}

\subsubsection{Серверные обработчики баз данных и событий над связями}
\paragraph{Обрабатываемые события:}
\begin{itemize}
  \item Вставка
  \item Обновление
  \item Удаление
\end{itemize}
\paragraph{Виды обработчиков:}
\begin{itemize}
  \item \textbf{Синхронные}
  \item \textbf{Асинхронные}
\end{itemize}

\paragraph{Синхронные обработчики}
\subparagraph{Описание}

Синхронные серверные обработчики выполняются внутри транзации внутри базы
данных и в случае ошибки
транзакция отменяется
\subparagraph{Примеры}

Создаём связь \texttt{Email} (тип: \texttt{\hyperlink{type.def}{Type}})

Создаём \hyperlink{SyncTextFile.Def}{SyncTextFile} содержащий такой код:

\begin{lstlisting}
({ data: { newLink: emailLink } }) => {
  const email = emailLink.value?.value;
  if (!email) {
    throw new Error(`Link ${emailLink.id} has not value`);
  }
  if (!email.includes("@")) {
    throw new Error(`Email ${email} does not include @`);
  }
};
\end{lstlisting}

Создаём \texttt{Handler} (от:
\hyperlink{dockerSupportsJs.def}{dockerSupportsJs}, до: наш
\hyperlink{SyncTextFile.Def}{SyncTextFile})

Создаём \texttt{HandleUpdate} (от: тип \texttt{Email}, до: наш
\texttt{Handler})

Примечание: \texttt{HandleUpdate} имеет начало в виде ТИПА \texttt{Email}, а
не конкретного \texttt{Email} (экземпляра), то есть "Тип \texttt{Email}
обрабатывается обработчиком"

Создаём связь \texttt{Email}

Обновляем связь \texttt{Email} (присваиваем ей значение)

В результате значение связи Email либо обновится, либо приведёт к ошибке.
Если операция проводилась в \hyperlink{DeepCase.Def}{DeepCase} - мы увидим ошибку на экране, если
операция проводилась программно - ошибка будет выброшена

\paragraph{Асинхронные обработчики}
\subparagraph{Описание}
Асинхронные серверные обработчики выполняются после транзакции, в результате
приводя к появлению следующих связей: \\
\newenvironment{handler_success_result_info}
{%
  \noindent При успешном выполнении: Связь\textendash триггер \textendash
  Then\textendash > Promise \textendash Resolved\textendash > \\
  PromiseResult {(с object value)}
}
{}
\newenvironment{handler_fail_result_info}
{%
  При ошибке: Связь\textendash триггер \textendash Then\textendash > Promise
  \textendash Rejected\textendash > PromiseResult {(с object value)}
}
{}
\begin{handler_success_result_info}
\end{handler_success_result_info}\\
\begin{handler_fail_result_info}
\end{handler_fail_result_info}\\
Результат выполнения асинхронного обработчика находится ниже по дереву
promiseTree от связи-триггера. В визуальном интерфейсе \hyperlink{DeepCase.Def}{DeepCase} можно увидеть
резузльтат используя контекстное меню->traveler->down->promiseTree

Асинхронные обработчики могут запускаться в разных средах. Одна из популярных -
докер среда, которая использует определенный инструмент, например - node для
запуска JavaScript кода.
\subparagraph{Примеры:}

\begin{itemize}
  \item Создаём связь \texttt{Email} (тип: \texttt{\hyperlink{type.def}{Type}})
  \item Создаём \hyperlink{SyncTextFile.Def}{SyncTextFile} содержащий такой
        код:
        \begin{lstlisting}
async ({ data: { newLink: emailLink } }) => {
  const email = emailLink.value?.value;
  if (!email) {
    throw new Error(`Link ${emailLink.id} has not value`);
  }
  if (!email.includes("@")) {
    throw new Error(`Email ${email} does not include @`);
  }
};
\end{lstlisting}
  \item Создаём \texttt{Handler} (от:
        \hyperlink{dockerSupportsJs.def}{dockerSupportsJs} , до: наш
        \hyperlink{SyncTextFile.Def}{SyncTextFile})
  \item Создаём \texttt{HandleUpdate} (от: тип \texttt{Email}, до: наш
        \texttt{Handler})
        \begin{verbatim}
    Примечание: HandleUpdate имеет начало в виде ТИПА Email,
    а не конкретного Email (экземпляра), то есть "Тип Email обрабатывается обработчиком"
    \end{verbatim}
  \item Создаём связь \texttt{Email}
  \item Обновляем связь \texttt{Email} (присваиваем ей значение)
  \item Видим результат асинхронного обработчика в виде связей:
        \begin{itemize}
          \item \begin{handler_success_result_info}
                \end{handler_success_result_info}\\

          \item \begin{handler_fail_result_info}
                \end{handler_fail_result_info}\\
        \end{itemize}
\end{itemize}

\paragraph{Справочник}
\subparagraph{Параметры обработчика}
\begin{enumerate}
  \item Объект, содержащий поля:
        \subitem{deep} - Дип Клиент
        \subitem{require} - функция для импортирования npm пакетов
        \subitem{data} - объект, содержащий поля:
        \subsubitem{newLink} - связь-триггер, на событие которой сработал
        обработчик
        \subsubitem{oldLink} - связь до операции
        \subsubitem{triggeredByLinkId} - связь, которая произвела операцию.
        Например связь пользователя
\end{enumerate}
\subsubsection{Серверные обработчики веб маршрута и порта}
\paragraph{Описание}
Серверные обработчики веб-маршрута и порта предоставляют возможность
эффективной обработки запросов по определенным веб-маршрутам и портам. Для
иллюстрации, представьте, что адрес нашего веб-сервера - deep-foundation.com.
Теперь мы можем легко настроить обработку определенного пути, например,
my-path, на конкретном порту, например, 5000, следуя данной конструкции:
deep-foundation.com/my-path:5000.

Эта гибкость позволяет точно настраивать поведение сервера в зависимости от
веб-маршрута и порта, что делает наш проект мощным инструментом для управления
трафиком и обработки запросов с высокой точностью.

Серверные обработчики реализованы с помощью npm пакета express
\paragraph{Примеры}
\subparagraph{Обработчик, возвращающий "ok" в любом случае}
\begin{itemize}
  \item Создать \hyperlink{SyncTextFile.Def}{SyncTextFile} с таким кодом:
        \begin{lstlisting}
(request, response) => {
    response.send("ok");
}
\end{lstlisting}
  \item Создать Handler от \hyperlink{dockerSupportsJs.def}{dockerSupportsJs}
        до нашего \hyperlink{SyncTextFile.Def}{SyncTextFile}
  \item Создать Route
  \item Создать HandleRoute от нашего Route до нашего Handler
  \item Создать Router
  \item Создать RouterStringUse от нашего Route до нашего Router, с значением
        веб-маршрута, который должен обрабатываться, например /my-path
  \item Создать Port с значением порта, который должен обрабатываться, например
        5000
  \item Создать RouterListening от нашего Router до нашего Port
\end{itemize}

\subparagraph{Обработчик, обрабатывающий входящий запрос}
В данном примере обработчик будет проверять поле isOk в входящем запрос, если
он true, то мы ответим строкой "ok", иначе "not ok"
\begin{itemize}
  \item Создать \hyperlink{SyncTextFile.Def}{SyncTextFile} с таким кодом:
        \begin{lstlisting}
async (
  request,
  response,
) => {
  if(request.isOk) {
    response.send("ok") 
  } else {
    response.send("not ok")
  }
}
\end{lstlisting}
  \item Создать Handler от \hyperlink{dockerSupportsJs.def}{dockerSupportsJs}
        до нашего \hyperlink{SyncTextFile.Def}{SyncTextFile}
  \item Создать Route
  \item Создать HandleRoute от нашего Route до нашего Handler
  \item Создать Router
  \item Создать RouterStringUse от нашего Route до нашего Router, с значением
        веб-маршрута, который должен обрабатываться, например /my-path
  \item Создать Port с значением порта, который должен обрабатываться, например
        5000
  \item Создать RouterListening от нашего Router до нашего Port
\end{itemize}

\paragraph{Справочник}
\subparagraph{Параметры обработчика}

\urldef{\requrl}\url{https://expressjs.com/en/api.html#req}
\urldef{\resurl}\url{https://expressjs.com/en/api.html#res}
\urldef{\midwareurl}\url{https://expressjs.com/en/guide/using-middleware.html}

\begin{enumerate}
  \item \texttt{Объект, который представляет HTTP-запрос и имеет свойства для
          строки запроса, параметров, тела, HTTP-заголовков и т. д. Подробное описание:
          \requrl}
  \item \texttt{Объект, который представляет HTTP-ответ, который приложение
          Express отправляет при получении HTTP-запроса. Подробное описание: \resurl}
  \item Объект, содержащий поля:
        \begin{enumerate}
          \item \texttt{deep} Дип Клиент
          \item \texttt{require} - функция для импортирования npm пакетов
          \item \texttt{next} - функция для передачи работы другому
                обработчику. Подробное описание: \midwareurl
        \end{enumerate}
\end{enumerate}
\subsection{DeepCase}
\subsubsection{Описание}
DeepCase\hypertarget{DeepCase.Def}{} является графическим визуальным интерфейсом Deep.
\hyperlink{DeepCase.Def}{DeepCase} позволяет взаимодействовать со связями: вставлять,
обновлять, удалять, просматривать, делать выборку связей,
путешествовать по ним, используя traveller, и ещё множество возможностей
\hyperlink{DeepCase.Def}{DeepCase} это npm пакет, который позволяет встраивать его компоненты, включая
отдельные клиентские обработчики, используя ClientHandler компонент в любой
проект, использующий npm пакет React
\subsubsection{Основные возможности}
\paragraph{Виуализация связи}
Визуализация конкретных связей реализована при помощи клиентских обработчиков.
Что бы увидеть визуализацию связи, нужно нажать на неё
\paragraph{Вставить связь}
Для того, что бы вставить связь, нужно нажать правкую кнопку мыши в пустом
месте и в открытом контекстном меню нажать на "Insert". После этого откроется
меню вставки связи, в котором есть поле для ввода что бы фильтровать связи по
названию, а так же сами связи ниже поля для ввода. Введите название нужной
связи, например \hyperlink{type.def}{Type} и ниже найдите связь с таким
названием. Вы можете
заметить, что там есть как минимум два \hyperlink{type.def}{Type}, один со
значком звёздочки, а
другой со значком папки. Связь с значком папки это Contain, следовательно нажав
на стрелку влево около этой связи, мы сможем увидеть откуда ведёт Contain
(после нажатия активная связь появляется над полем для ввода), а нажав на
стрелку вправо сможем увидеть на какую связь указывает Contain, следовательно
Contain будет указывать на ту самую связь со звёздочкой, то есть вы можете
выбрать \hyperlink{type.def}{Type} либо нажав на стрелку вправо у его
Contain'a, либо нажав на сам
\hyperlink{type.def}{Type} (на название). Удостоверьтесь, что над полем для
ввода отображается нужная
связь и после этого нажмите на галочку справа внизу от меню вставки, что бы
активировать вставку этой связи. После этого вы увидите уведомление слева внизу
о том, что вы сейчас вставляете связь определённого типа, а так же сказано
какая это связь, Node (точка), или же она является связью между двумя
определёнными типами связей. Если это Node вам предложат нажать в любом
свободном месте, что бы вставить связь, если же это не Node, но нажать не
отпуская на связь и привести появившуюся линию к другой связи, что бы создать
связь между этими связями. Так же можно нажать крестик на уведомлении что бы
отменить вставку
\paragraph{Обновить связь}

% Дип клиент
\subsection{Дип клиент}
Дип клиент это класс в JavaScript, находящийся в npm библиотеке
@deep-foundation/deeplinks, используется для использования дипа
программно в JavaScript среде

\subsubsection{Вставка связей}

\paragraph{Примеры}

\subparagraph{Вставка связи с типом 1}
\begin{lstlisting}
await deep.insert({
  type_id: 1,
});
\end{lstlisting}

\subparagraph{Вставка связи с типом \hyperlink{type.def}{Type}}
\begin{lstlisting}
await deep.insert({
  type_id: await deep.id("@deep-foundation/core", "Type"),
});
\end{lstlisting}

\subparagraph{Вставка связи с типом Reply из пакета messenger}
\begin{lstlisting}
await deep.insert({
  type_id: await deep.id("messenger", "Reply"),
  from_id: await deep.id("MyPackageName", "MyMessage"),
  to_id: await deep.id("MyPackageName", "MyConversation"),
});
\end{lstlisting}

\subparagraph{Вставка строкового значения для связи 100}
\begin{lstlisting}
await deep.insert(
  {
    link_id: 100,
    value: "MyValue",
  },
  {
    table: "strings",
  }
);
\end{lstlisting}

\subsubsection{Получение связей}

\paragraph{Примеры}

\subparagraph{Получение связи с типом 1}
\begin{lstlisting}
await deep.select({
  type_id: 1,
});
\end{lstlisting}

\subparagraph{Получение связи с типом \hyperlink{type.def}{Type}}
\begin{lstlisting}
await deep.select({
  type_id: await deep.id("@deep-foundation/core", "Type"),
});
\end{lstlisting}

\subparagraph{Получение связи с типом Reply из пакета messenger}
\begin{lstlisting}
await deep.select({
  type_id: await deep.id("messenger", "Reply"),
  from_id: await deep.id("MyPackageName", "MyMessage"),
  to_id: await deep.id("MyPackageName", "MyConversation"),
});
\end{lstlisting}

\subparagraph{Получение строкового значения для связи 100}
\begin{lstlisting}
await deep.select(
  {
    link_id: 100,
  },
  {
    table: "strings",
  }
);
\end{lstlisting}

\subsubsection{Обновление связей}

Примечание: используйте любое другое ограничение, например, \{from: 100, to:
150\}.

\paragraph{Примеры}

\subparagraph{Обновление начала и конца}
\begin{lstlisting}
await deep.update(
  {
    id: 1,
  },
  {
    from_id: 5,
    to_id: 5
  }
);
\end{lstlisting}

\subparagraph{Обновление строкового значения}
\begin{lstlisting}
await deep.update(
  {
    link_id: 1,
  },
  {
    value: "MyNewValue",
  },
  {
    table: "strings",
  }
);
\end{lstlisting}

\subsubsection{Удаление связей}

\paragraph{Примеры \\}

Удаление связи с типом 1

\begin{lstlisting}
await deep.delete({
  type_id: 1,
});
\end{lstlisting}

Удаление связи с типом \hyperlink{type.def}{Type}

\begin{lstlisting}
await deep.delete({
  type_id: await deep.id("@deep-foundation/core", "Type"),
});
\end{lstlisting}

Удаление связи с определённым типом, началом, концом
\begin{lstlisting}
await deep.delete({
  type_id: 5,
  from_id: 10,
  to_id: 15,
});
\end{lstlisting}

Удаление строкового значения для связи 100
\begin{lstlisting}
await deep.delete(
  {
    link_id: 100,
  },
  {
    table: "strings",
  }
);
\end{lstlisting}

\subsection{@deep-foundation/core}
\subsubsection{Описание}
@deep-foundation/core\hypertarget{core.def}{} это встроенный пакет, которые
содержит самые важные типы для работы с Deep
\subsubsection{Связи}
\paragraph*{Type}
Тип Type\hypertarget{type.def}{} используется для создания новых типов
\paragraph*{SyncTextFile}
Тип SyncTextFile\hypertarget{SyncTextFile.Def}{} используется для хранения
любого строкового значения
\paragraph*{Any}
Тип Any\hypertarget{any.def}{} может использоваться для ограничений
\subparagraph*{Начало/конец типа}
Например есть при создании типа А вы можете указать, что его началом
обязательно должен быть Б, а концом может быть любая связь, для этого концом у
типа будет указан Any
\subparagraph*{Обрабатываемый тип}
Any может использоваться как обрабатываемый тип, в таком случае обработчик
будет обрабатывать экземпляры всех типов
\paragraph*{Handler}
Тип Handler\hypertarget{handler.def}{} используется для создания обработчика.
Его началом является экземпляр \hyperlink{supports.def}{Supports}, а концом
любая связь, содержащая код в строковом значении
\paragraph*{Supports}
Тип Supports\hypertarget{handler.def}{} используется для создания среды
выполнения обработчика. Примером среды выполнения обработчика является
\hyperlink{dockerSupportsJs.def}{dockerSupportsJs}
\paragraph*{dockerSupportsJs}
Связь dockerSupportsJs\hypertarget{dockerSupportsJs.def}{} используется для
поддержки JavaScript в Docker. Что бы использовать эту среду для обработчика,
нужно сделать эту связь началом связи \hyperlink{handler.def}{Handler}
\paragraph*{HandleInsert}
Связь HandleInsert\hypertarget{HandleInsert.Def}{} используется для обработки
вставки экземпляров определённого типа. Например, что бы обрабатывать вставку
экземпляров типа \hyperlink{type.def}{Type}, нужно создать HandleInsert с
началом типом \hyperlink{type.def}{Type} и концом обработчиком, то есть
экземпляром \hyperlink{handler.def}{Handler}
\paragraph*{HandleUpdate}
Связь HandleUpdate\hypertarget{HandleUpdate.Def}{} используется для обработки
обновлений экземпляров определённого типа. Например, что бы обрабатывать
обновления экземпляров типа \hyperlink{type.def}{Type}, нужно создать
HandleUpdate с началом типом \hyperlink{type.def}{Type} и концом обработчиком,
то есть экземпляром \hyperlink{handler.def}{Handler}
\paragraph*{HandleUpdate}
Связь HandleDelete\hypertarget{HandleDelete.Def}{} используется для обработки
удалений экземпляров определённого типа. Например, что бы обрабатывать удаления
экземпляров типа \hyperlink{type.def}{Type}, нужно создать HandleDelete с
началом типом \hyperlink{type.def}{Type} и концом обработчиком, то есть
экземпляром \hyperlink{handler.def}{Handler}

% Таблицы
\subsection{Таблицы}
Deep использует различные таблицы, такие как links (для хранения связей) и
numbers, strings, objects (для хранения значений привязанных к связям).

\begin{itemize}
  \item \textbf{links} - связи
  \item \textbf{strings} - строковые значения
  \item \textbf{numbers} - числовые значения
  \item \textbf{objects} - объектные значения (фактически JSON, поэтому можно
        вставлять числа/строки в таблицу objects, а не только объекты)
  \item \textbf{selectors} - селекторы
  \item \textbf{mp} - материализация пути связей
  \item \textbf{tree} - деревья
  \item \textbf{\texttt{promise\_links}} - для очереди выполнения обработчиков
  \item \textbf{\texttt{handlers}} - обработчики
  \item \textbf{\texttt{reserved}} - зарезервированные связи
  \item \textbf{\texttt{bool\_exp}} - используется для компиляции
        дополнительных условий в селекторах
  \item \textbf{\texttt{can}} - позволяет ответить быстро на вопрос есть ли у
        той или иной связи прав
  \item \textbf{\texttt{files}} - хранит файлы
\end{itemize}

\subsection{Часть регистрации изменений}

\begin{table}[h]
  \centering
  \caption{Часть регистрации изменений}
  \begin{tabular}{|c|p{8cm}|c|}
    \hline
    \textbf{№} & \textbf{Изменение}     & \textbf{Дата} \\
    \hline
    1          & Добавлена документация & 17.11.2023    \\
    \hline
     % 2 & Изменены требования к системе & 05.02.2023 \\
  \end{tabular}
\end{table}

\end{document}
