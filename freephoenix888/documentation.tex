\documentclass{article}
\usepackage[utf8]{inputenc} % For Unicode characters
\usepackage[T2A]{fontenc}    % Font encoding for Cyrillic characters
\usepackage{graphicx}	     % Required for inserting images
\usepackage{titletoc}
\usepackage{listings}
\usepackage{url}
\usepackage{titling}
\usepackage{lipsum} % Для генерации случайного текста
% Syntax Highlighting
\usepackage{xcolor}
\usepackage{listings}
\usepackage{listingsutf8}

\lstdefinelanguage{TypeScript}{
  keywords=[1]{break, case, catch, continue, debugger, default, delete, do,
      else, false, finally, for, function, if, in, instanceof, new, null, return,
      switch, this, throw, true, try, typeof, var, void, while, with},
  keywordstyle=[1]\color{blue}\bfseries,
  keywords=[2]{abstract, as, constructor, declare, enum, export, extends, from,
      get, implements, import, interface, let, module, private, protected, public,
      set, static, yield, in},
  keywordstyle=[2]\color{teal}\bfseries,
  identifierstyle=\color{black},
  commentstyle=\color{green!40!black},
  stringstyle=\color{purple},
  sensitive=true
}

\lstset{
  language=TypeScript,
  extendedchars=true,
  basicstyle=\small\ttfamily,
  showstringspaces=false,
  showspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=5pt,
  tabsize=2,
  breaklines=true,
  showtabs=false,
  xleftmargin=2em,  % Adjust the value according to your indentation style
}

\renewcommand{\contentsname}{Содержание} % Change the name of the table of contents

\title{Deep Foundation}
\author{FreePhoenix888}
\date{November 2023}

\begin{document}

\maketitle

\newpage % новая страница

\section{Вступление}
\subsection{Аннотация}

Данный текст представляет собой описание основных концепций и структур в рамках
архитектуры Deep. Deep представляет собой систему, организованную вокруг
понятий связей, пакетов и обработчиков.

\begin{enumerate}
  \item \textbf{Связи:}
        \begin{itemize}
          \item Связи могут иметь различные атрибуты, такие как идентификатор,
                тип, начало, конец и значение.
          \item Тип, начало и конец связи являются связями, что создает
                структуру, где связи могут указывать друг на друга.
          \item Приведены примеры различных типов связей, таких как Message,
                Conversation, Reply и др.
        \end{itemize}

  \item \textbf{Связи-типы:}
        \begin{itemize}
          \item Любая связь может использоваться как тип для создания другой
                связи
          \item Если связь является точкой (без начала и конца) - экземпляр
                такой связи тоже будет точкой
          \item Если связь ведёт от связи А к связи Б, то экземпляр этой связи
                должен вести от экземпляра связи А к экземпляру связи Б
          \item Если нужно что бы экземпляр связи мог быть связан с любой
                связью,
                то нужно использовать встроенный тип Any из пакета
                @deep-foundation/core
        \end{itemize}

  \item \textbf{Пакеты:}
        \begin{itemize}
          \item Существует встроенный в Deep тип Contain, обозначающий
                принадлежность связей к определенному пакету.
          \item Пакеты не обязательно содержат связи напрямую; они могут
                указывать на связи из других пакетов. В таком случае пакет становится зависимым от другого пакета
        \end{itemize}

  \item \textbf{Обработчики:}
        \begin{itemize}
          \item Виды серверных обработчиков: обработчики базы данных,
                обработчики веб-маршрута и порта
          \item Серверные обработчики баз данных могут быть синхронными и
                асинхронными
          \item Клиентские обработчики предоставляют возможность показывать
                визуальный графический интерфейс для связи в DeepCase
                (визуальный графический
                интерфейс Deep)
        \end{itemize}

  \item \textbf{DeepCase:}
        \begin{itemize}
          \item DeepCase это графический визуальный интерфейс Deep
          \item Визуализация конкретных связей реализована при помощи клиентских обработчиков
          \item DeepCase позволяет взаимодействовать со связями: вставлять,
                обновлять, удалять
          \item DeepCase имеет функции для быстрой и удобной работы с Deepом
        \end{itemize}

  \item \textbf{Дип клиент:}
        \begin{itemize}
          \item Дип Клиент для программного взаимодействия с Deep в среде
                JavaScript, позволяет вставлять, получать, обновлять и удалять
                связи.
        \end{itemize}

  \item \textbf{Таблицы:}
        \begin{itemize}
          \item Deep использует различные таблицы, такие как links, strings,
                numbers и objects, для хранения различных типов данных.
        \end{itemize}
\end{enumerate}

Приведены примеры использования Дип Клиента для различных операций, таких как
вставка связей различных типов, получение данных, обновление и удаление.

% Add a subsection heading to the table of contents
% \addtocontents{toc}{\protect\subsection{Содержание}}

% Table of contents
\tableofcontents

\section{Основная часть}

% Краткое описание
\subsection{Краткое описание}

\subsection{Основные концепты}

\begin{itemize}
  \item Связи
  \item Связи-типы
  \item Пакеты, содержащие связи (сам пакет тоже является связью)
  \item Обработчики событий
  \item Материализованный путь связей, деревья
  \item DeepCase (графический визуальный интерфейс Deep)
  \item Дип Клиент
  \item Таблицы
\end{itemize}

% Связи
\subsection{Связи}

\subsubsection{Описание}

\paragraph{Аттрибуты связи}

\begin{itemize}
  \item \texttt{id} (число)
  \item \texttt{Тип} (\texttt{type}) (число)
  \item Начало (\texttt{from}) (число)
  \item Конец (\texttt{to}) (число)
  \item Значение (строка/число/объект)
\end{itemize}

\paragraph{Практическое правило (Rule of thumb)}
Тип, начало, конец - являются связью. Связи указывают на связи. Таким образом,
любая связь может быть типом/началом/концом для другой связи.

\paragraph{Пример}

\begin{itemize}
  \item \texttt{Message (type: Type)}
  \item \texttt{Conversation(type: Type)}
  \item \texttt{Reply(type: Type, from: Message, to: Conversation)}
  \item \texttt{UrgentMessage(type: Message)}
  \item \texttt{UrgentReply(type: Reply, from: UrgentMessage, to:
          Conversation)}
\end{itemize}

\subsection{Связи-типы}
\paragraph{Описание}
Любая связь может быть типом для вставки другой связи.
\paragraph{Сценарии использования связи как типа}
Если связь является точкой (без начала и конца) - экземпляр такой связи тоже
будет точкой
Если связь является связью между двумя определёнными типами - вы сможете
вставить связь только между связями этих определённых типов
Совет: если связь должна вести от/до неопределённого типа связи, то следует
использовать встроенный тип Any из пакета @deep-foundation/core
\paragraph{Примеры}
\subparagraph{Пример с связью точкой}
\begin{enumerate}
  \item Вставьте связь типа Type без начала и конца
  \item Вставьте связь типа "Ваш тип" без начала и конца
\end{enumerate}
\subparagraph{Пример с связью между определёнными связями}
\begin{enumerate}
  \item Вставьте связь типа Type от Package до User
  \item Вставьте связь вашего типа от экземпляра Package до экземпляра User
  \item Попробуйте вставить связь вашего типа от экземпляра не Package до
        экземпляра не User, и увидите ошибку
\end{enumerate}
\subparagraph{Пример с связью между Any и User}
\begin{enumerate}
  \item Вставьте связь типа Type от Any до User
  \item Вставьте связь вашего типа от любой связи до экземпляра User и
        созерцайте, что начало вашей связи может быть любым
\end{enumerate}
\subparagraph{Пример с связью между Any и Any}
\begin{enumerate}
  \item Вставьте связь типа Type от Any до User
  \item Вставьте связь вашего типа от любой связи до любой связи и
        созерцайте, что начало и конец вашей связи может быть любым
\end{enumerate}
% Пакеты
\subsection{Пакеты}

В Deep есть встроенный тип \texttt{Contain}, который указывает на
принадлежность. Чаще всего он используется для того, чтобы пакет
\texttt{Contain} в себе определенные связи, необходимые для его работы.
Пакеты не обязательно содержат связи напрямую; они могут
                указывать на связи из других пакетов. В таком случае пакет становится зависимым от другого пакета


Пример использования пакета \texttt{@freephoenix888/dependency}:

\begin{lstlisting}
await deep.insert({
  type_id: await deep.id("@freephoenix888/dependency", "Dependency"),
  from_id: await deep.id("deep-memo"),
  to_id: await deep.id("capacitor-device"),
  in: {
    data: [
      {
        type_id: containTypeLinkId,
        from_id: dependantPackageLinkId,
        string: {
          data: {
            value: `MyDependency`,
          },
        },
      },
    ],
  },
});
\end{lstlisting}

% Обработчики
\subsection{Обработчики}

\subsubsection{Виды обработчиков}
\begin{itemize}
  \item \textbf{Серверные обработчики событий баз данных}
  \item \textbf{Серверные обработчики веб маршрута и порта}
  \item \textbf{Клиентские обработчики}
\end{itemize}

\subsubsection{Серверные обработчики событий баз данных}
\paragraph{Обрабатываемые события:}
\begin{itemize}
  \item Вставка
  \item Обновление
  \item Удаление
\end{itemize}
\paragraph{Виды обработчиков:}
\begin{itemize}
  \item \textbf{Синхронные}
  \item \textbf{Асинхронные}
\end{itemize}

\paragraph{Синхронные обработчики}
\subparagraph{Описание}

Синхронные серверные обработчики выполняются внутри транзации и в случае ошибки
транзакция отменяется
\subparagraph{Примеры}

Создаём связь \texttt{Email} (тип: \texttt{Type})

Создаём \texttt{SyncTextFile} содержащий такой код:

\begin{lstlisting}
({ data: { newLink: emailLink } }) => {
  const email = doubleLink.value?.value;
  if (!email) {
    throw new Error(`Link ${doubleLink.id} has not value`);
  }
  if (!email.includes("@")) {
    throw new Error(`Email ${email} does not include @`);
  }
};
\end{lstlisting}

Создаём \texttt{Handler} (от: \texttt{dockerSupportsJs} (из
\texttt{@deep-foundation/core}), до: наш \texttt{SyncTextFile})

Создаём \texttt{HandleUpdate} (от: тип \texttt{Email}, до: наш
\texttt{Handler})

Примечание: \texttt{HandleUpdate} имеет начало в виде ТИПА \texttt{Double}, а
не конкретного \texttt{Double} (экземпляра), то есть "Тип \texttt{Email}
обрабатывается обработчиком"

Создаём связь \texttt{Email}

Обновляем связь \texttt{Email} (присваиваем ей значение)

В результате значение связи Email либо обновится, либо приведёт к ошибке.
Если операция проводилась в DeepCase - мы увидим ошибку на экране, если
операция проводилась программно - ошибка будет выброшена

\paragraph{Асинхронные обработчики}
\subparagraph{Описание}
Асинхронные серверные обработчики выполняются после транзакции, в результате
приводя к появлению следующих связей:
При успешном выполнении: Связь-триггер --Then-> Promise --Resolved->
PromiseResult (с object value)
При ошибке: Связь-триггер --Then-> Promise --Rejected-> PromiseResult (с object
value)

Асинхронные обработчики могут запускаться в разных средах. Одна из популярных -
докер среда, которая использует определенный инструмент, например - node для
запуска JavaScript кода.
\subparagraph{Примеры:}

\begin{itemize}
  \item Создаём связь \texttt{Email} (тип: \texttt{Type})
  \item Создаём \texttt{SyncTextFile} содержащий такой код:
        \begin{lstlisting}
async ({ data: { newLink: emailLink } }) => {
  const email = emailLink.value?.value;
  if (!email) {
    throw new Error(`Link ${emailLink.id} has not value`);
  }
  if (!email.includes("@")) {
    throw new Error(`Email ${email} does not include @`);
  }
};
\end{lstlisting}
  \item Создаём \texttt{Handler} (от: \texttt{dockerSupportsJs} (из
        \texttt{@deep-foundation/core}), до: наш \texttt{SyncTextFile})
  \item Создаём \texttt{HandleUpdate} (от: тип \texttt{Email}, до: наш
        \texttt{Handler})
        \begin{verbatim}
    Примечание: \texttt{HandleUpdate} имеет начало в виде ТИПА \texttt{Email},
    а не конкретного \texttt{Email} (экземпляра), то есть "Тип \texttt{Email} обрабатывается обработчиком"
    \end{verbatim}
  \item Создаём связь \texttt{Email}
  \item Обновляем связь \texttt{Email} (присваиваем ей значение)
  \item Видим результат асинхронного обработчика в виде связей:
        \begin{itemize}
          \item При успешном выполнении: Связь-триггер --Then-> Promise
                --Resolved-> PromiseResult (с object value)
          \item При ошибке: Связь-триггер --Then-> Promise --Rejected->
                PromiseResult (с object value)
        \end{itemize}
\end{itemize}

\paragraph{Справочник}
\subparagraph{Параметры обработчика}
\begin{enumerate}
  \item Объект, содержащий поля:
        \subitem{deep} - Дип Клиент
        \subitem{require} - функция для импортирования npm пакетов
        \subitem{data} - объект, содержащий поля:
        \subsubitem{newLink} - связь-триггер, на событие которой сработал
        обработчик
        \subsubitem{oldLink} - связь до операции
        \subsubitem{triggeredByLinkId} - связь, которая произвела операцию.
        Например связь пользователя
\end{enumerate}
\subsubsection{Серверные обработчики веб маршрута и порта}
\paragraph{Описание}
Серверные обработчики веб-маршрута и порта предоставляют возможность
эффективной обработки запросов по определенным веб-маршрутам и портам. Для
иллюстрации, представьте, что адрес нашего веб-сервера - deep-foundation.com.
Теперь мы можем легко настроить обработку определенного пути, например,
my-path, на конкретном порту, например, 5000, следуя данной конструкции:
deep-foundation.com/my-path:5000.

Эта гибкость позволяет точно настраивать поведение сервера в зависимости от
веб-маршрута и порта, что делает наш проект мощным инструментом для управления
трафиком и обработки запросов с высокой точностью.

Серверные обработчики реализованы с помощью npm пакета express
\paragraph{Примеры}
\subparagraph{Обработчик, возвращающий "ok" в любом случае}
\begin{itemize}
  \item Создать SyncTextFile с таким кодом:
        \begin{lstlisting}
() => {
    return "ok";
}
\end{lstlisting}
  \item Создать Handler от dockerSupportsJs до нашего SyncTextFile
  \item Создать Route
  \item Создать HandleRoute от нашего Route до нашего Handler
  \item Создать Router
  \item Создать RouterStringUse от нашего Route до нашего Router, с значением
        веб-маршрута, который должен обрабатываться, например /my-path
  \item Создать Port с значением порта, который должен обрабатываться, например
        5000
  \item Создать RouterListening от нашего Router до нашего Port
\end{itemize}

\subparagraph{Обработчик, обрабатывающий входящий запрос}
В данном примере обработчик будет проверять поле isOk в входящем запрос, если
он true, то мы ответим строкой "ok", иначе "not ok"
\begin{itemize}
  \item Создать SyncTextFile с таким кодом:
        \begin{lstlisting}
async (
  request,
  response,
) => {
  if(request.isOk) {
    response.send("ok") 
  } else {
    response.send("not ok")
  }
}
\end{lstlisting}
  \item Создать Handler от dockerSupportsJs до нашего SyncTextFile
  \item Создать Route
  \item Создать HandleRoute от нашего Route до нашего Handler
  \item Создать Router
  \item Создать RouterStringUse от нашего Route до нашего Router, с значением
        веб-маршрута, который должен обрабатываться, например /my-path
  \item Создать Port с значением порта, который должен обрабатываться, например
        5000
  \item Создать RouterListening от нашего Router до нашего Port
\end{itemize}

\paragraph{Справочник}
\subparagraph{Параметры обработчика}
\begin{enumerate}
  \item \textbf{Объект, который представляет HTTP-запрос и имеет свойства для
          строки запроса, параметров, тела, HTTP-заголовков и т. д. Подробное
          описание:
          \url{https://expressjs.com/en/api.html#req}}
  \item \textbf{Объект, который представляет HTTP-ответ, который приложение
          Express отправляет при получении HTTP-запроса. Подробное описание:
          \url{https://expressjs.com/en/api.html#res}}
  \item Объект, содержащий поля:
        \subitem{deep} Дип Клиент
        \subitem{require} require - функция для импортирования npm пакетов
        \subitem{next} - функция для передачи работы другому обработчику.
        Подробное описание:
        \url{https://expressjs.com/en/guide/using-middleware.html}
\end{enumerate}
\subsection{DeepCase (графический визуальный интерфейс Deep)}
\subsubsection{Описание}
DeepCase является графическим интерфейсом Deep. Он позволяет быстро и удобно
взаимодействовать с связями, вставлять, обновлять, удалять, и же ещё множество
других возможностей
\subsubsection{Основные возможности}
\paragraph{Виуализация связи}
Визуализация конкретных связей реализована при помощи клиентских обработчиков. Что бы увидеть визуализацию связи, нужно нажать на неё
\paragraph{Вставить связь}
Для того, что бы вставить связь, нужно нажать правкую кнопку мыши в пустом
месте и в открытом контекстном меню нажать на "Insert". После этого откроется
меню вставки связи, в котором есть поле для ввода что бы фильтровать связи по
названию, а так же сами связи ниже поля для ввода. Введите название нужной
связи, например Type и ниже найдите связь с таким названием. Вы можете
заметить, что там есть как минимум два Type, один со значком звёздочки, а
другой со значком папки. Связь с значком папки это Contain, следовательно нажав
на стрелку влево около этой связи, мы сможем увидеть откуда ведёт Contain
(после нажатия активная связь появляется над полем для ввода), а нажав на
стрелку вправо сможем увидеть на какую связь указывает Contain, следовательно
Contain будет указывать на ту самую связь со звёздочкой, то есть вы можете
выбрать Type либо нажав на стрелку вправо у его Contain'a, либо нажав на сам
Type (на название). Удостоверьтесь, что над полем для ввода выбрана нужная
связь и после этого нажмите на галочку справа внизу от меню вставки, что бы
активировать вставку этой связи. После этого вы увидите уведомление слева внизу
о том, что вы сейчас вставляете связь определённого типа, а так же сказано
какая это связь, Node (точка), или же она является связью между двумя
определёнными типами связей. Если это Node вам предложат нажать в любом
свободном месте, что бы вставить связь, если же это не Node, но нажать не
отпуская на связь и привести появившуюся линию к другой связи, что бы создать
связь между этими связями. Так же можно нажать крестик на уведомлении что бы
отменить вставку
% Дип клиент
\subsection{Дип клиент}
Дип клиент это класс в JavaScript, находящийся в npm библиотеке
@deep-foundation/deeplinks, используется для удобного использования дипа
программно в JavaScript среде

\subsubsection{Вставка связей}

\paragraph{Примеры}

\subparagraph{Вставка связи с типом 1}
\begin{lstlisting}
await deep.insert({
  type_id: 1,
});
\end{lstlisting}

\subparagraph{Вставка связи с типом Type из пакета @deep-foundation/core}
\begin{lstlisting}
await deep.insert({
  type_id: await deep.id("@deep-foundation/core", "Type"),
});
\end{lstlisting}

\subparagraph{Вставка связи с типом Reply из пакета messenger}
\begin{lstlisting}
await deep.insert({
  type_id: await deep.id("messenger", "Reply"),
  from_id: await deep.id(deep.linkId, "MyMessage"),
  to_id: await deep.id(deep.linkId, "MyConversation"),
});
\end{lstlisting}

\subparagraph{Вставка строкового значения для связи 100}
\begin{lstlisting}
await deep.insert(
  {
    link_id: 100,
    value: "MyValue",
  },
  {
    table: "strings",
  }
);
\end{lstlisting}

\subsubsection{Получение связей}

\paragraph{Примеры}

\subparagraph{Получение связи с типом 1}
\begin{lstlisting}
await deep.select({
  type_id: 1,
});
\end{lstlisting}

\subparagraph{Получение связи с типом Type из пакета @deep-foundation/core}
\begin{lstlisting}
await deep.select({
  type_id: await deep.id("@deep-foundation/core", "Type"),
});
\end{lstlisting}

\subparagraph{Получение связи с типом Reply из пакета messenger}
\begin{lstlisting}
await deep.select({
  type_id: await deep.id("messenger", "Reply"),
  from_id: await deep.id(deep.linkId, "MyMessage"),
  to_id: await deep.id(deep.linkId, "MyConversation"),
});
\end{lstlisting}

\subparagraph{Получение строкового значения для связи 100}
\begin{lstlisting}
await deep.select(
  {
    link_id: 100,
    value: "MyValue",
  },
  {
    table: "strings",
  }
);
\end{lstlisting}

\subsubsection{Обновление связей}

Примечание: используйте любое другое ограничение, например, \{from: 100, to:
150\}.

\paragraph{Примеры}

\subparagraph{Обновление начала}
\begin{lstlisting}
await deep.update(
  {
    id: 1,
  },
  {
    from_id: 5,
  }
);
\end{lstlisting}

\subparagraph{Обновление строкового значения}
\begin{lstlisting}
await deep.update(
  {
    link_id: 1,
  },
  {
    value: "MyNewValue",
  },
  {
    table: "strings",
  }
);
\end{lstlisting}

\subsubsection{Удаление связей}

\paragraph{Примеры}

\subparagraph{Удаление связи с типом 1}
\begin{lstlisting}
await deep.delete({
  type_id: 1,
});
\end{lstlisting}

\subparagraph{Удаление связи с типом Type из пакета @deep-foundation/core}
\begin{lstlisting}
await deep.delete({
  type_id: await deep.id("@deep-foundation/core", "Type"),
});
\end{lstlisting}

\subparagraph{Удаление связи с типом Reply из пакета messenger}
\begin{lstlisting}
await deep.delete({
  type_id: await deep.id("messenger", "Reply"),
  from_id: await deep.id(deep.linkId, "MyMessage"),
  to_id: await deep.id(deep.linkId, "MyConversation"),
});
\end{lstlisting}

\subparagraph{Удаление строкового значения для связи 100}
\begin{lstlisting}
await deep.delete(
  {
    link_id: 100,
    value: "MyValue",
  },
  {
    table: "strings",
  }
);
\end{lstlisting}

% Таблицы
\subsection{Таблицы}

\begin{itemize}
  \item \textbf{links} - связи
  \item \textbf{strings} - строковые значения
  \item \textbf{numbers} - числовые значения
  \item \textbf{objects} - объектные значения (фактически JSON, поэтому можно
        вставлять числа/строки в таблицу objects, а не только объекты)
  \item \textbf{selectors} - селекторы
  \item \textbf{mp} - материализация пути связи
  \item \textbf{tree} - деревья
  \item \textbf{\texttt{promise\_links}} - для очереди выполнения обработчиков
  \item \textbf{\texttt{handlers}} - обработчики
  \item \textbf{\texttt{reserved}} - зарезервированные связи
  \item \textbf{\texttt{bool\_exp}} - используется для компиляции дополнительных условий в селекторах
  \item \textbf{\texttt{can}} - позволяет ответить быстро на вопрос есть ли у той или иной связи прав
  \item \textbf{\texttt{files}} - хранит файлы
\end{itemize}

\subsection{Часть регистрации изменений}

\begin{table}[h]
  \centering
  \caption{Часть регистрации изменений}
  \begin{tabular}{|c|p{8cm}|c|}
    \hline
    \textbf{№} & \textbf{Изменение}     & \textbf{Дата} \\
    \hline
    1          & Добавлена документация & 17.11.2023    \\
    \hline
     % 2 & Изменены требования к системе & 05.02.2023 \\
  \end{tabular}
\end{table}

\end{document}
