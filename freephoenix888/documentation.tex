\documentclass{article}
\usepackage[utf8]{inputenc} % For Unicode characters
\usepackage[T2A]{fontenc}    % Font encoding for Cyrillic characters
\usepackage{graphicx}	     % Required for inserting images
\usepackage{titletoc}
\usepackage{listings}
\usepackage{titling}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{lipsum} % Для генерации случайного текста
% Syntax Highlighting
\usepackage{xcolor}
\usepackage{listings}
\usepackage{listingsutf8}

\lstdefinelanguage{TypeScript}{
  keywords=[1]{break, case, catch, continue, debugger, default, delete, do,
      else, false, finally, for, function, if, in, instanceof, new, null,
      return,
      switch, this, throw, true, try, typeof, var, void, while, with},
  keywordstyle=[1]\color{blue}\bfseries,
  keywords=[2]{abstract, as, constructor, declare, enum, export, extends, from,
      get, implements, import, interface, let, module, private, protected,
      public,
      set, static, yield, in},
  keywordstyle=[2]\color{teal}\bfseries,
  identifierstyle=\color{black},
  commentstyle=\color{green!40!black},
  stringstyle=\color{purple},
  sensitive=true
}

\lstset{
  language=TypeScript,
  extendedchars=true,
  basicstyle=\small\ttfamily,
  showstringspaces=false,
  showspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=5pt,
  tabsize=2,
  breaklines=true,
  showtabs=false,
  xleftmargin=2em,  % Adjust the value according to your indentation style
}

\renewcommand{\contentsname}{Содержание} % Change the name of the table of contents

\title{Deep Foundation}
\author{FreePhoenix888}
\date{November 2023}

\begin{document}

\maketitle

\newpage % новая страница

\section{Вступление}
\subsection{Аннотация}

Данный текст представляет собой описание основных концепций и структур в рамках
архитектуры Deep. Deep представляет собой систему, организованную вокруг
понятий связей, пакетов и обработчиков.

\begin{enumerate}
  \item \textbf{Связи:}
        \begin{itemize}
          \item Связи могут иметь различные атрибуты, такие как идентификатор,
                тип, начало, конец и значение.
          \item Тип, начало и конец связи являются связями, что создает
                структуру, где связи могут указывать друг на друга.
          \item Приведены примеры различных типов связей, таких как Message,
                Conversation, Reply и др.
        \end{itemize}

  \item \textbf{Связи-типы:}
        \begin{itemize}
          \item Любая связь может использоваться как тип для создания другой
                связи
          \item Если связь является точкой (без начала и конца) - экземпляр
                такой связи тоже будет точкой
          \item Если связь ведёт от связи А к связи Б, то экземпляр этой связи
                должен вести от экземпляра связи А к экземпляру связи Б
          \item Если нужно что бы экземпляр связи мог быть связан с любой
                связью,
                то нужно использовать встроенный тип \hyperlink{any.Def}{Any}
        \end{itemize}

  \item \textbf{Пакеты:}
        \begin{itemize}
          \item Существует встроенный в Deep тип
                \hyperlink{Contain.Def}{Contain}, обозначающий
                принадлежность связей к определенному пакету.
          \item Пакеты не обязательно содержат связи напрямую; они могут
                указывать на связи из других пакетов. В таком случае пакет
                становится зависимым от другого пакета
        \end{itemize}

  \item \textbf{Обработчики:}
        \begin{itemize}
          \item Виды серверных обработчиков: обработчики базы данных,
                обработчики веб-маршрута, обработчики порта
          \item Серверные обработчики баз данных и событий над связями могут
                быть синхронными (выполняются в рамках транзакции и внутри базы
                данных) и
                асинхронными (выполняются в Docker'е, за пределами транзакции
                внутри базы
                данных)
          \item Клиентские обработчики предоставляют возможность показывать
                визуальный графический интерфейс для связи в
                \hyperlink{DeepCase.Def}{DeepCase}
          \item Серверные обработчики по расписанию позволяют выполнять
                определенные задачи по расписанию
        \end{itemize}

  \item \textbf{\hyperlink{DeepCase.Def}{DeepCase:}}
        \begin{itemize}
          \item \hyperlink{DeepCase.Def}{DeepCase} это графический визуальный
                интерфейс Deep
          \item Визуализация конкретных связей реализована при помощи
                клиентских обработчиков
          \item \hyperlink{DeepCase.Def}{DeepCase} позволяет взаимодействовать
                со связями: вставлять,
                обновлять, удалять, просматривать, делать выборку связей,
                путешествовать по ним, используя traveller, и ещё множество
                возможностей
          \item \hyperlink{DeepCase.Def}{DeepCase} это npm пакет, который
                позволяет встраивать его
                компоненты, включая отдельные клиентские обработчики, используя
                ClientHandler
                компонент в любой проект, использующий npm пакет React
        \end{itemize}

  \item \textbf{Дип клиент:}
        \begin{itemize}
          \item Дип Клиент для программного взаимодействия с Deep в среде
                JavaScript, позволяет вставлять, получать, обновлять и удалять
                связи.
        \end{itemize}

  \item \textbf{Таблицы:}
        \begin{itemize}
          \item Deep использует использует различные таблицы, такие как links
                (для хранения связей) и numbers, strings, objects (для хранения
                значений
                привязанных к связям)
        \end{itemize}
\end{enumerate}

Приведены примеры использования Дип Клиента для различных операций, таких как
вставка связей различных типов, получение данных, обновление и удаление.

% Add a subsection heading to the table of contents
% \addtocontents{toc}{\protect\subsection{Содержание}}

% Table of contents
\tableofcontents

\section{Основная часть}

% Связи
\subsection{Связи}

\subsubsection{Описание}

\paragraph{Аттрибуты связи}

\begin{itemize}
  \item \texttt{id} (число)
  \item \texttt{Тип} (\texttt{type}) (число)
  \item Начало (\texttt{from}) (число)
  \item Конец (\texttt{to}) (число)
  \item Значение (строка/число/объект)
\end{itemize}

Тип, начало, конец - являются связью. Связи указывают на связи. Таким образом,
любая связь может быть типом/началом/концом для другой связи.

\subsubsection{Пример}
\begin{itemize}
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без
          начала и конца} и \hyperlink{FAQ.HowToSetName}{назовите} её Conversation
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без
          начала и конца} и
        \hyperlink{FAQ.HowToSetName}{назовите} её Message
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} от Message до Conversation и
        \hyperlink{FAQ.HowToSetName}{назовите} её Reply
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа Reply от
        Message до Conversation и \hyperlink{FAQ.HowToSetName}{назовите} её
        UrgentMessage
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа Reply от
        UrgentMessage до Conversation и \hyperlink{FAQ.HowToSetName}{назовите} её
        UrgentReply
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{Core.Value.Def}{Value} от UrgentMessage до
        \hyperlink{Core.String.Def}{String}
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Conversation}
        \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без начала и конца}
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{UrgentMessage}
        \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без начала и конца}
  \item \hyperlink{DeepCase.UpdateLink.Def}{Обновите} экземпляр связи
        UrgentMessage
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа UrgentReply от
        UrgentMessage до Conversation
\end{itemize}

\subsection{Связи-типы}
\subsubsection{Описание}
Любая связь может быть типом для вставки другой связи. \\
Тип задаёт ограничение для экземпляров этого типа. \\
Если у типа нет начала или конца - у экземпляра его тоже не будет. \\
Если у типа начало это связь А, а конец это связь Б, то экземпляр должен иметь
начало в виде экземпляра связи А, а конец в виде экземпляра связи Б. \\
Если у типа начало это связь \hyperlink{Core.Any.Def}{Any}, то экземпляр может
иметь начало в виде любой связи. \\
Если у типа конец это связь \hyperlink{Core.Any.Def}{Any}, то экземпляр может
иметь конец в виде любой связи. \\

\subsubsection{Примеры}
\paragraph{Тип без начала и конца}
\begin{itemize}
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без
          начала и конца} и \hyperlink{FAQ.HowToSetName}{назовите} её MyNode
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyNode
        \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без начала и конца}
\end{itemize}
\subparagraph{Тип с определёнными началом и концом}
\begin{itemize}
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без
          начала и конца} и \hyperlink{FAQ.HowToSetName}{назовите} её MyNode1
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без
          начала и конца} и \hyperlink{FAQ.HowToSetName}{назовите} её MyNode2
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без
          начала и конца} и \hyperlink{FAQ.HowToSetName}{назовите} её MyNode3
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} \hyperlink{FAQ.HowToInsertLinkWithFromAndTo}{с
          началом MyMode1 и концом MyNode2} и \hyperlink{FAQ.HowToSetName}{назовите} её
        MyLink
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyNode1
        \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без начала и конца} и
        \hyperlink{FAQ.HowToSetName}{назовите} её myNode1
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyNode2
        \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без начала и конца} и
        \hyperlink{FAQ.HowToSetName}{назовите} её myNode2
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyNode3
        \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без начала и конца} и
        \hyperlink{FAQ.HowToSetName}{назовите} её myNode3
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyLink
        \hyperlink{FAQ.HowToInsertLinkWithFromAndTo}{с началом myMode1 и концом
          myNode2} и \hyperlink{FAQ.HowToSetName}{назовите} её myLink
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyLink
        \hyperlink{FAQ.HowToInsertLinkWithFromAndTo}{с началом myMode1 и концом
          myNode3} и увидите ошибку, потому что вы выставили такое ограчничение:
        экземпляры MyLink должен иметь начало в виде экземпляра  MyNode1, а конец в
        виде экземпляра MyNode2, следовательно вы не можете использовать экземпляр
        MyNode3 как конец
\end{itemize}
\subparagraph{Тип между Any и определённым концом}
\begin{itemize}
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без
          начала и конца} и \hyperlink{FAQ.HowToSetName}{назовите} её MyNode1
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без
          начала и конца} и \hyperlink{FAQ.HowToSetName}{назовите} её MyNode2
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} \hyperlink{FAQ.HowToInsertLinkWithFromAndTo}{с
          началом Any и концом MyNode1} и \hyperlink{FAQ.HowToSetName}{назовите} её
        MyLink
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyNode1
        \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без начала и конца} и
        \hyperlink{FAQ.HowToSetName}{назовите} её myNode1
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyNode2
        \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без начала и конца} и
        \hyperlink{FAQ.HowToSetName}{назовите} её myNode2
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyLink
        \hyperlink{FAQ.HowToInsertLinkWithFromAndTo}{с началом myMode1 и концом
          myNode1} и \hyperlink{FAQ.HowToSetName}{назовите} её myLink и не увидите
        ошибку, потому что ограничение типа MyLink удовлетворено: начало - экземпляр
        любого типа, конец - экземпляр MyNode1
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyLink
        \hyperlink{FAQ.HowToInsertLinkWithFromAndTo}{с началом myMode2 и концом
          myNode1} и \hyperlink{FAQ.HowToSetName}{назовите} её myLink и не увидите
        ошибку, потому что ограничение типа MyLink удовлетворено: начало - экземпляр
        любого типа, конец - экземпляр MyNode1
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyLink
        \hyperlink{FAQ.HowToInsertLinkWithFromAndTo}{с началом myMode1 и концом
          myNode2} и увидите ошибку, потому что вы выставили такое ограчничение:
        экземпляры MyLink могут иметь начало в виде экземпляра любого типа, а конец
        должен быть в виде экземпляра MyNode1, следовательно вы не можете использовать
        экземпляр MyNode2 как конец
\end{itemize}
\subparagraph{Тип между определённым началом и концом Any}
\begin{itemize}
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без
          начала и конца} и \hyperlink{FAQ.HowToSetName}{назовите} её MyNode1
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без
          начала и конца} и \hyperlink{FAQ.HowToSetName}{назовите} её MyNode2
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} \hyperlink{FAQ.HowToInsertLinkWithFromAndTo}{с
          началом MyNode1 и концом Any} и \hyperlink{FAQ.HowToSetName}{назовите} её
        MyLink
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyNode1
        \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без начала и конца} и
        \hyperlink{FAQ.HowToSetName}{назовите} её myNode1
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyNode2
        \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без начала и конца} и
        \hyperlink{FAQ.HowToSetName}{назовите} её myNode2
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyLink
        \hyperlink{FAQ.HowToInsertLinkWithFromAndTo}{с началом myMode1 и концом
          myNode1} и \hyperlink{FAQ.HowToSetName}{назовите} её myLink и не увидите
        ошибку, потому что ограничение типа MyLink удовлетворено: начало - экземпляр
        MyNode1, конец - экземпляр любого типа
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyLink
        \hyperlink{FAQ.HowToInsertLinkWithFromAndTo}{с началом myMode2 и концом
          myNode1} и \hyperlink{FAQ.HowToSetName}{назовите} её myLink и увидите ошибку,
        потому что вы выставили такое ограчничение: экземпляры MyLink должны иметь
        начало в виде экземпляра MyNode1, а конец может быть в виде экземпляра любого
        типа, следовательно вы не можете использовать экземпляр MyNode2 как начало
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyLink
        \hyperlink{FAQ.HowToInsertLinkWithFromAndTo}{с началом myMode1 и концом
          myNode2} и не увидите ошибку, потому что ограничение типа MyLink удовлетворено:
        начало - экземпляр MyNode1, конец - экземпляр любого типа
\end{itemize}
\subparagraph{Тип между Any и Any}
\begin{itemize}
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без
          начала и конца} и \hyperlink{FAQ.HowToSetName}{назовите} её MyNode1
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без
          начала и конца} и \hyperlink{FAQ.HowToSetName}{назовите} её MyNode2
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} \hyperlink{FAQ.HowToInsertLinkWithFromAndTo}{с
          началом Any и концом Any} и \hyperlink{FAQ.HowToSetName}{назовите} её MyLink
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyNode1
        \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без начала и конца} и
        \hyperlink{FAQ.HowToSetName}{назовите} её myNode1
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyNode2
        \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без начала и конца} и
        \hyperlink{FAQ.HowToSetName}{назовите} её myNode2
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyLink
        \hyperlink{FAQ.HowToInsertLinkWithFromAndTo}{с началом myMode1 и концом
          myNode1} и \hyperlink{FAQ.HowToSetName}{назовите} её myLink и не увидите
        ошибку, потому что ограничение типа MyLink удовлетворено: начало - экземпляр
        любого типа, конец - экземпляр любого типа
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyLink
        \hyperlink{FAQ.HowToInsertLinkWithFromAndTo}{с началом myMode1 и концом
          myNode2} и \hyperlink{FAQ.HowToSetName}{назовите} её myLink и не увидите
        ошибку, потому что ограничение типа MyLink удовлетворено: начало - экземпляр
        любого типа, конец - экземпляр любого типа
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyLink
        \hyperlink{FAQ.HowToInsertLinkWithFromAndTo}{с началом myMode2 и концом
          myNode1} и \hyperlink{FAQ.HowToSetName}{назовите} её myLink и не увидите
        ошибку, потому что ограничение типа MyLink удовлетворено: начало - экземпляр
        любого типа, конец - экземпляр любого типа
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyLink
        \hyperlink{FAQ.HowToInsertLinkWithFromAndTo}{с началом myMode2 и концом
          myNode2} и \hyperlink{FAQ.HowToSetName}{назовите} её myLink и не увидите
        ошибку, потому что ограничение типа MyLink удовлетворено: начало - экземпляр
        любого типа, конец - экземпляр любого типа
\end{itemize}
% Пакеты
\subsection{Пакеты}
\subsubsection{Описание}
Пакет предназначены для упаковки связей вместе в одну связь, которую можно
выложить, скачать, точно так-же, как вы устанавливаете какое либо программное
обеспечение состоящее из различных файлов. \\
Пакет это тоже связь, экземпляр \hyperlink{Core.Package}{Package} \\
Принадлежность связи к пакету определяется с помощью экземпляра
\hyperlink{Contain.Def}{Contain}. То есть что бы ваша связь находилась в
пакетее - нужно иметь экземпляр \hyperlink{Core.Contain.Def}{Contain}, ведущий
от пакета к связи \\
Если связь пакета А указывает началом/концом/типом на связь пакета Б, то пакет
А становится зависимым от пакета Б \\
\subsubsection{Примеры}
\subparagraph{Создание пакета}
\begin{itemize}
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{Core.Package.Def}{Type}
        \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без начала и конца} и
        \hyperlink{FAQ.HowToSetName}{назовите} её MyPackage
\end{itemize}
\subparagraph{Добавление связи в пакет}
\begin{itemize}
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{Core.Package.Def}{Type}
        \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без начала и конца} и
        \hyperlink{FAQ.HowToSetName}{назовите} её MyPackage. Кстати, теперь ваш пакет
        зависит от пакета \hyperlink{Core.Def}{@deep-foundation/core}, потому что
        использует его связь \hyperlink{Core.Type.Def}{Type} как тип для нашей связи
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{type.Def}{Type} \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без
          начала и конца} и \hyperlink{FAQ.HowToSetName}{назовите} её MyNode1
\end{itemize}
\subparagraph{Публикация пакета}
\begin{itemize}
  \item Что бы опубликовать пакет нужно
        \hyperlink{DeepCase.InsertLink.Def}{вставить} связь типа
        \hyperlink{NpmPackager.Token.Def}{Type}
        \hyperlink{FAQ.HowToInsertLinkWithoutFromAndTo}{без начала и конца} и дать ей
        значение равное вашему токену из npm, который вы можете получить на
        \url{https://www.npmjs.com/}
  \item Нажмите левой кнопкой мыши на MyPackage и увидите клиентский
        обработчик, показывающий визуализацию для пакета. Введите название и версию
        пакета и нажмите кнопку Save, а затем Publish
  \item Теперь нам нужно увидеть связь Publish, которая создалась благодаря
        нажатию на кнопку Publish. Откройте контекстное меню MyPackage, нажмите
        Traveller, затем TODO: В разработке % TODO:
  \item Что бы увидеть результат выполнения обработчика выкладывания пакета -
        откройте контекстное меню Publish, нажмите Traveller, затем затем Down, затем
        promiseTree, и вы увидите всё, что ниже по дереву promiseTree, то есть
        результаты всех асинхронных обработчиков, в данном случае одного
\end{itemize}

% Обработчики
\subsection{Обработчики}

\subsubsection{Виды обработчиков}
\begin{itemize}
  \item \textbf{Серверные обработчики баз данных и событий над связями}
  \item \textbf{Серверные обработчики веб маршрута и порта}
  \item \textbf{Серверные обработчики порта}
  \item \textbf{Серверные обработчики по расписанию}
  \item \textbf{Клиентские обработчики}
\end{itemize}

\subsubsection{Серверные обработчики баз данных и событий над связями}
\paragraph{Обрабатываемые события:}
\begin{itemize}
  \item Вставка
  \item Обновление
  \item Удаление
\end{itemize}
\paragraph{Виды обработчиков:}
\begin{itemize}
  \item \textbf{Синхронные}
  \item \textbf{Асинхронные}
\end{itemize}

\paragraph{Синхронные обработчики}
\subparagraph{Описание}

Синхронные серверные обработчики выполняются внутри транзации внутри базы
данных и в случае ошибки
транзакция отменяется
\subparagraph{Примеры}

Создаём связь \texttt{Email} (тип: \texttt{\hyperlink{type.Def}{Type}})

Создаём \hyperlink{SyncTextFile.Def}{SyncTextFile} содержащий такой код:

\begin{lstlisting}
({ data: { newLink: emailLink } }) => {
  const email = emailLink.value?.value;
  if (!email) {
    throw new Error(`Link ${emailLink.id} has not value`);
  }
  if (!email.includes("@")) {
    throw new Error(`Email ${email} does not include @`);
  }
};
\end{lstlisting}

Создаём \texttt{Handler} (от:
\hyperlink{dockerSupportsJs.Def}{dockerSupportsJs}, до: наш
\hyperlink{SyncTextFile.Def}{SyncTextFile})

Создаём \texttt{HandleUpdate} (от: тип \texttt{Email}, до: наш
\texttt{Handler})

Примечание: \texttt{HandleUpdate} имеет начало в виде ТИПА \texttt{Email}, а
не конкретного \texttt{Email} (экземпляра), то есть "Тип \texttt{Email}
обрабатывается обработчиком"

Создаём связь \texttt{Email}

Обновляем связь \texttt{Email} (присваиваем ей значение)

В результате значение связи Email либо обновится, либо приведёт к ошибке.
Если операция проводилась в \hyperlink{DeepCase.Def}{DeepCase} - мы увидим
ошибку на экране, если
операция проводилась программно - ошибка будет выброшена

\paragraph{Асинхронные обработчики}
\subparagraph{Описание}
Асинхронные серверные обработчики выполняются после транзакции, в результате
приводя к появлению следующих связей: \\
\newenvironment{handler_success_result_info}
{%
  \noindent При успешном выполнении: Связь\textendash триггер \textendash
  Then\textendash > Promise \textendash Resolved\textendash > \\
  PromiseResult {(с object value)}
}
{}
\newenvironment{handler_fail_result_info}
{%
  При ошибке: Связь\textendash триггер \textendash Then\textendash > Promise
  \textendash Rejected\textendash > PromiseResult {(с object value)}
}
{}
\begin{handler_success_result_info}
\end{handler_success_result_info}\\
\begin{handler_fail_result_info}
\end{handler_fail_result_info}\\
Результат выполнения асинхронного обработчика находится ниже по дереву
promiseTree от связи-триггера. В визуальном интерфейсе
\hyperlink{DeepCase.Def}{DeepCase} можно увидеть
резузльтат используя контекстное меню->traveler->down->promiseTree

Асинхронные обработчики могут запускаться в разных средах. Одна из популярных -
докер среда, которая использует определенный инструмент, например - node для
запуска JavaScript кода.
\subparagraph{Примеры:}

\begin{itemize}
  \item Создаём связь \texttt{Email} (тип: \texttt{\hyperlink{type.Def}{Type}})
  \item Создаём \hyperlink{SyncTextFile.Def}{SyncTextFile} содержащий такой
        код:
        \begin{lstlisting}
async ({ data: { newLink: emailLink } }) => {
  const email = emailLink.value?.value;
  if (!email) {
    throw new Error(`Link ${emailLink.id} has not value`);
  }
  if (!email.includes("@")) {
    throw new Error(`Email ${email} does not include @`);
  }
};
\end{lstlisting}
  \item Создаём \texttt{Handler} (от:
        \hyperlink{dockerSupportsJs.Def}{dockerSupportsJs} , до: наш
        \hyperlink{SyncTextFile.Def}{SyncTextFile})
  \item Создаём \texttt{HandleUpdate} (от: тип \texttt{Email}, до: наш
        \texttt{Handler})
        \begin{verbatim}
    Примечание: HandleUpdate имеет начало в виде ТИПА Email,
    а не конкретного Email (экземпляра), то есть "Тип Email обрабатывается обработчиком"
    \end{verbatim}
  \item Создаём связь \texttt{Email}
  \item Обновляем связь \texttt{Email} (присваиваем ей значение)
  \item Видим результат асинхронного обработчика в виде связей:
        \begin{itemize}
          \item \begin{handler_success_result_info}
                \end{handler_success_result_info}\\

          \item \begin{handler_fail_result_info}
                \end{handler_fail_result_info}\\
        \end{itemize}
\end{itemize}

\paragraph{Справочник}
\subparagraph{Параметры обработчика}
\begin{enumerate}
  \item Объект, содержащий поля:
        \subitem{deep} - Дип Клиент
        \subitem{require} - функция для импортирования npm пакетов
        \subitem{data} - объект, содержащий поля:
        \subsubitem{newLink} - связь-триггер, на событие которой сработал
        обработчик
        \subsubitem{oldLink} - связь до операции
        \subsubitem{triggeredByLinkId} - связь, которая произвела операцию.
        Например связь пользователя
\end{enumerate}
\subsubsection{Серверные обработчики веб маршрута и порта}
\paragraph{Описание}
Серверные обработчики веб-маршрута и порта предоставляют возможность
эффективной обработки запросов по определенным веб-маршрутам и портам. Для
иллюстрации, представьте, что адрес нашего веб-сервера - deep-foundation.com.
Теперь мы можем легко настроить обработку определенного пути, например,
my-path, на конкретном порту, например, 5000, следуя данной конструкции:
deep-foundation.com/my-path:5000.

Эта гибкость позволяет точно настраивать поведение сервера в зависимости от
веб-маршрута и порта, что делает наш проект мощным инструментом для управления
трафиком и обработки запросов с высокой точностью.

Серверные обработчики реализованы с помощью npm пакета express
\paragraph{Примеры}
\subparagraph{Обработчик, возвращающий "ok" в любом случае}
\begin{itemize}
  \item Создать \hyperlink{SyncTextFile.Def}{SyncTextFile} с таким кодом:
        \begin{lstlisting}
(request, response) => {
    response.send("ok");
}
\end{lstlisting}
  \item Создать \hyperlink{Handler.Def}{Handler} от
        \hyperlink{dockerSupportsJs.Def}{dockerSupportsJs}
        до нашего \hyperlink{SyncTextFile.Def}{SyncTextFile}
  \item Создать \hyperlink{Route.Def}{Route}
  \item Создать \hyperlink{HandleRoute.Def}{HandleRoute} от нашего
        \hyperlink{Route.Def}{Route} до нашего \hyperlink{Handler.Def}{Handler}
  \item Создать \hyperlink{Router.Def}{Router}
  \item Создать \hyperlink{RouterStringUse.Def}{RouterStringUse} от нашего
        \hyperlink{Route.Def}{Route} до нашего \hyperlink{Router.Def}{Router},
        с
        значением
        веб-маршрута, который должен обрабатываться, например /my-path
  \item Создать \hyperlink{Port.Def}{Port} с значением порта, который должен
        обрабатываться, например
        5000
  \item Создать \hyperlink{RouterListening.Def}{RouterListening} от нашего
        \hyperlink{Router.Def}{Router} до нашего \hyperlink{Port.Def}{Port}
\end{itemize}

\subparagraph{Обработчик, обрабатывающий входящий запрос}
В данном примере обработчик будет проверять поле isOk в входящем запрос, если
он true, то мы ответим строкой "ok", иначе "not ok"
\begin{itemize}
  \item Создать \hyperlink{SyncTextFile.Def}{SyncTextFile} с таким кодом:
        \begin{lstlisting}
async (
  request,
  response,
) => {
  if(request.isOk) {
    response.send("ok") 
  } else {
    response.send("not ok")
  }
}
\end{lstlisting}
  \item Создать \hyperlink{Handler.Def}{Handler} от
        \hyperlink{dockerSupportsJs.Def}{dockerSupportsJs}
        до нашего \hyperlink{SyncTextFile.Def}{SyncTextFile}
  \item Создать \hyperlink{Route.Def}{Route}
  \item Создать \hyperlink{HandleRoute.Def}{HandleRoute} от нашего
        \hyperlink{Route.Def}{Route} до нашего \hyperlink{Handler.Def}{Handler}
  \item Создать \hyperlink{Router.Def}{Router}
  \item Создать \hyperlink{RouterStringUse.Def}{RouterStringUse} от нашего
        \hyperlink{Route.Def}{Route} до нашего \hyperlink{Router.Def}{Router},
        с
        значением
        веб-маршрута, который должен обрабатываться, например /my-path
  \item Создать \hyperlink{Port.Def}{Port} с значением порта, который должен
        обрабатываться, например
        5000
  \item Создать \hyperlink{RouterListening.Def}{RouterListening} от нашего
        \hyperlink{Router.Def}{Router} до нашего \hyperlink{Port.Def}{Port}
\end{itemize}

\paragraph{Справочник}
\subparagraph{Параметры обработчика}

\urldef{\requrl}\url{https://expressjs.com/en/api.html#req}
\urldef{\resurl}\url{https://expressjs.com/en/api.html#res}
\urldef{\midwareurl}\url{https://expressjs.com/en/guide/using-middleware.html}

\begin{enumerate}
  \item{request} \texttt{Объект, который представляет HTTP-запрос и имеет
    свойства для
    строки запроса, параметров, тела, HTTP-заголовков и т. д. Подробное
    описание:
    \requrl}
  \item{response} \texttt{Объект, который представляет HTTP-ответ, который
    приложение
    Express отправляет при получении HTTP-запроса. Подробное описание:
    \resurl}
  \item{otherArgs} Объект, содержащий поля:
  \begin{enumerate}
    \item \texttt{deep} Дип Клиент
    \item \texttt{require} - функция для импортирования npm пакетов
    \item \texttt{next} - функция для передачи работы другому
          обработчику. Подробное описание: \midwareurl
  \end{enumerate}
\end{enumerate}
\subsubsection{Серверные обработчики порта}
% TODO
TODO: В разработке
\subsubsection*{Серверные обработчики по расписанию}
% TODO
TODO: В разработке
\subsection{DeepCase}
\subsubsection{Описание}
DeepCase\hypertarget{DeepCase.Def}{} является графическим визуальным
интерфейсом Deep.
\hyperlink{DeepCase.Def}{DeepCase} позволяет взаимодействовать со связями:
вставлять,
обновлять, удалять, просматривать, делать выборку связей,
путешествовать по ним, используя traveller, и ещё множество возможностей
\hyperlink{DeepCase.Def}{DeepCase} это npm пакет, который позволяет встраивать
его компоненты, включая
отдельные клиентские обработчики, используя ClientHandler компонент в любой
проект, использующий npm пакет React
\subsubsection{Основные возможности}
\paragraph{Виуализация связи}
Визуализация конкретных связей реализована при помощи клиентских обработчиков.
Что бы увидеть визуализацию связи, нужно нажать на неё
\paragraph{Вставить связь}
Для того, что бы \hypertarget{DeepCase.InsertLink.Def}{вставить связь}, нужно
нажать правкую кнопку мыши в пустом
месте и в открытом контекстном меню нажать на "Insert". После этого откроется
меню вставки связи, в котором есть поле для ввода что бы фильтровать связи по
названию, а так же сами связи ниже поля для ввода. Введите название нужной
связи, например \hyperlink{type.Def}{Type} и ниже найдите связь с таким
названием. Вы можете
заметить, что там есть как минимум два \hyperlink{type.Def}{Type}, один со
значком звёздочки, а
другой со значком папки. Связь с значком папки это
\hyperlink{Contain.Def}{Contain}, следовательно нажав
на стрелку влево около этой связи, мы сможем увидеть откуда ведёт
\hyperlink{Contain.Def}{Contain}
(после нажатия активная связь появляется над полем для ввода), а нажав на
стрелку вправо сможем увидеть на какую связь указывает
\hyperlink{Contain.Def}{Contain}, следовательно
\hyperlink{Contain.Def}{Contain} будет указывать на ту самую связь со
звёздочкой, то есть вы можете
выбрать \hyperlink{type.Def}{Type} либо нажав на стрелку вправо у его
\hyperlink{Contain.Def}{Contain}'a, либо нажав на сам
\hyperlink{type.Def}{Type} (на название). Удостоверьтесь, что над полем для
ввода отображается нужная
связь и после этого нажмите на галочку справа внизу от меню вставки, что бы
активировать вставку этой связи. После этого вы увидите уведомление слева внизу
о том, что вы сейчас вставляете связь определённого типа, а так же сказано
какая это связь, Node (точка), или же она является связью между двумя
определёнными типами связей. Если это Node вам предложат нажать в любом
свободном месте, что бы вставить связь, если же это не Node, но нажать не
отпуская на связь и привести появившуюся линию к другой связи, что бы создать
связь между этими связями. Так же можно нажать крестик на уведомлении что бы
отменить вставку
\paragraph{Обновить связь}
Для того, что бы обновить связь, нужно открыть контекстное меню связи и нажать
на кнопку Update, после чего протянуть линию от нового начала до нового конца
связи
Заметка: если не протягивать линию, а нажать на связь один раз, то она станет и
началом и концом связи
\paragraph{Удалить связь}
Для того, что бы удалить связь, нужно открыть контекстное меню связи и нажать
на кнопку "Delete"
\paragraph{Удаление ниже по дереву
  containTree}\hypertarget{containTree.Deletion.Example}{}
Для того, что бы удалить все связи ниже по дереву
\hyperlink{containTree.Def}{containTree}, нужно открыть контекстное меню связи
и нажать на кнопку "Delete Down"
\paragraph*{Traveller}
\hyperlink{Traveller.Def}{Traveller} используется для путешествия по связям.
При нажатии на кнопку Traveller в контекстном меню вам сначала нужно выбрать в
каком направлении вы хотите путешествовать, а затем выставить ограничение
путешествия.
Если вы путешествуете вверх или вниз по дереву, следовательно после этого вам
предоставят возможность выбрать дерево, по которому вы будете путешествовать.
Если вы путешествуете по чему-либо другому, например in/out, то после этого вам
предоставят возможность выбрать отфильтровать эти связи по определённому
признаку, либо же показать все связи
\paragraph*{Редактор}
\hypertarget{Editor.Def}{Редактор} используется для:
\begin{itemize}
  \item Редактирования значения связей
  \item Управлением обработчиками
  \item Просмотра результатов обработчиков
\end{itemize}

% Дип клиент

\subsection{@deep-foundation/core}
\subsubsection{Описание}
@deep-foundation/core\hypertarget{core.Def}{} это встроенный пакет, которые
содержит самые важные типы для работы с Deep
\subsubsection{Связи}
\paragraph*{Type}
Тип Type\hypertarget{type.Def}{} используется для создания новых типов
\paragraph*{Contain}
Тип Contain\hypertarget{Contain.Def}{} используется для обозначения
принадлежности, а так же для присваивания имени связи. Например пакет, что бы
содержать в себе другие связи - имеет \hyperlink{Contain.Def}{Contain} от себя
до другой связи. Если вы хотите дать имя связи - обновите значение экземпляра
\hyperlink{Contain.Def}{Contain}
\paragraph*{SyncTextFile}
Тип SyncTextFile\hypertarget{SyncTextFile.Def}{} используется для хранения
любого строкового значения
\paragraph*{Any}
Тип Any\hypertarget{any.Def}{} может использоваться для ограничений
\subparagraph*{Начало/конец типа}
Например есть при создании типа А вы можете указать, что его началом
обязательно должен быть Б, а концом может быть любая связь, для этого концом у
типа будет указан Any
\subparagraph*{Обрабатываемый тип}
Any может использоваться как обрабатываемый тип, в таком случае обработчик
будет обрабатывать экземпляры всех типов
\paragraph*{Handler}
Тип Handler\hypertarget{handler.Def}{} используется для создания обработчика.
Его началом является экземпляр \hyperlink{supports.Def}{Supports}, а концом
любая связь, содержащая код в строковом значении
\paragraph*{Supports}
Тип Supports\hypertarget{handler.Def}{} используется для создания среды
выполнения обработчика. Примером среды выполнения обработчика является
\hyperlink{dockerSupportsJs.Def}{dockerSupportsJs}
\paragraph*{dockerSupportsJs}
Связь dockerSupportsJs\hypertarget{dockerSupportsJs.Def}{} используется для
поддержки JavaScript в Docker. Что бы использовать эту среду для обработчика,
нужно сделать эту связь началом связи \hyperlink{handler.Def}{Handler}
\paragraph*{HandleInsert}
Связь HandleInsert\hypertarget{HandleInsert.Def}{} используется для обработки
вставки экземпляров определённого типа. Например, что бы обрабатывать вставку
экземпляров типа \hyperlink{type.Def}{Type}, нужно создать HandleInsert с
началом типом \hyperlink{type.Def}{Type} и концом обработчиком, то есть
экземпляром \hyperlink{handler.Def}{Handler}
\paragraph*{HandleUpdate}
Связь HandleUpdate\hypertarget{HandleUpdate.Def}{} используется для обработки
обновлений экземпляров определённого типа. Например, что бы обрабатывать
обновления экземпляров типа \hyperlink{type.Def}{Type}, нужно создать
HandleUpdate с началом типом \hyperlink{type.Def}{Type} и концом обработчиком,
то есть экземпляром \hyperlink{handler.Def}{Handler}
\paragraph*{HandleUpdate}
Связь HandleDelete\hypertarget{HandleDelete.Def}{} используется для обработки
удалений экземпляров определённого типа. Например, что бы обрабатывать удаления
экземпляров типа \hyperlink{type.Def}{Type}, нужно создать HandleDelete с
началом типом \hyperlink{type.Def}{Type} и концом обработчиком, то есть
экземпляром \hyperlink{handler.Def}{Handler}
\paragraph*{Tree}
Тип Tree\hypertarget{Tree.Def}{} используется для создания дерева
\paragraph*{TreeIncludeDown}
Тип TreeIncludeDown\hypertarget{TreeIncludeDown.Def}{} используется для
включения в дерево связи, по направлению вниз
\paragraph*{TreeIncludeUp}
Тип TreeIncludeUp\hypertarget{TreeIncludeUp.Def}{} используется для включения в
дерево связи, по направлению вверх
\paragraph*{TreeIncludeNode}
Тип TreeIncludeNode\hypertarget{TreeIncludeNode.Def}{} используется для
включения в дерево связи, у которой нет начала и конца
\paragraph*{Route}
Тип Route\hypertarget{Route.Def}{} используется для создания веб-маршрута
\paragraph*{HandleRoute}
Связь HandleRoute\hypertarget{HandleRoute.Def}{} используется для обработки
веб-маршрута

\paragraph*{Router}
Тип Router\hypertarget{Router.Def}{} используется для создания роутера
\paragraph*{RouterStringUse}
Связь RouterStringUse\hypertarget{RouterStringUse.Def}{} используется для
указания веб-маршрута, который должен обрабатываться
\paragraph*{Port}
Тип Port\hypertarget{Port.Def}{} используется для создания порта
\paragraph*{RouterListening}
Связь RouterListening\hypertarget{RouterListening.Def}{} используется для
указания порта, который должен обрабатываться
\paragraph*{Space}
Тип Space\hypertarget{Space.Def}{} используется для создания пространства

\subsection{Материализованный путь, деревья}
\subsubsection{Описание}
Для каждой связи выстраивается материализованный путь. Деревья используют эту
концепцию и позволяют упрощать взаимодействие с группами связей.
Самым простым и понятным примером является
\hyperlink{containTree.Deletion.Example}{Удаление ниже по дереву containTree}
Вы сами можете создавать деревья!
\subsubsection{Примеры}
\paragraph{Создание дерева}
\begin{itemize}
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{Tree}{Tree} и \hyperlink{FAQ.HowToSetName}{назовите} её myTree
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{Type.Def}{Type} и \hyperlink{FAQ.HowToSetName}{назовите} её MyNode1
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{Type.Def}{Type} и \hyperlink{FAQ.HowToSetName}{назовите} её MyNode2
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{Type.Def}{Type}, с началом \hyperlink{Core.Any.Def}{Any}, концом
        \hyperlink{Core.Any.Def}{Any} и \hyperlink{FAQ.HowToSetName}{назовите} её
        MyDownLink
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{Type.Def}{Type}, с началом \hyperlink{Core.Any.Def}{Any}, концом
        \hyperlink{Core.Any.Def}{Any} и \hyperlink{FAQ.HowToSetName}{назовите} её
        MyUpLink
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь
        \hyperlink{TreeIncludeNode.Def}{TreeIncludeNode} от
        экземпляра \hyperlink{Core.Tree.Def}{Tree} до MyNode1
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь
        \hyperlink{TreeIncludeNode.Def}{TreeIncludeNode} от
        экземпляра \hyperlink{Core.Tree.Def}{Tree} до MyNode2
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь
        \hyperlink{TreeIncludeDown.Def}{TreeIncludeDown} от
        экземпляра \hyperlink{Core.Tree.Def}{Tree} до MyDownLink
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь
        \hyperlink{TreeIncludeNode.Def}{TreeIncludeUp} от
        экземпляра \hyperlink{Core.Tree.Def}{Tree} до MyUpLink
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyNode1
        и \hyperlink{FAQ.HowToSetName}{назовите} её myNode1
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyNode2
        и \hyperlink{FAQ.HowToSetName}{назовите} её myNode2
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        MyDownLink с началом myNode1 и концом myNode2 и \hyperlink{FAQ.HowToSetName}{назовите} её myDownLink
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа MyUpLink с началом myNode2 и концом myNode1 и
        \hyperlink{FAQ.HowToSetName}{назовите} её myUpLink
  \item \hyperlink{DeepCase.InsertLink.Def}{Вставьте} связь типа
        \hyperlink{Space.Def}{Space}, что бы пеерстать видеть наши связи и показать
        работу деревьев, используя Traveller
  \item Открываем контекстное меню экземпляра \hyperlink{Space.Def}{Space} и
        нажимаем кнопку "Space" что бы перейти в это пространство
  \item Открываем контекстное меню, нажимаем кнопку Query, вводим в поле для
        ввода myNode1, нажимаем на myNode1, нажимаем галочку, что бы увидеть
        эту связь
  \item Открываем контекстное меню, нажимаем кнопку
        \hyperlink{Traveller.Def}{Traveller}, нажимаем кнопку Down, нажимаем на
        кнопку
        myTree
  \item Созерцайте путешествие от связи myNode1 вниз по дереву myTree, вы
        должны видеть связи myNode1, myDownLink, myNode2
  \item Открываем меню DeepCase, нажимаем крестик около слова Space, что бы
        выйти из текущего пространства и вернуться в пространство нашего
        пользователя
  \item Снова создаём новое пространство, заходим в него
  \item Снова с помощью Query запрашиваем связь, но уже myNode2
  \item С помощью \hyperlink{Traveller.Def}{Traveller} запрашиваем связи вверх
        по дереву myTree
  \item Видим связи myNode2, myDownLink, myNode1
  \item Возвращаемся в предыдущее пространство
\end{itemize}

\subsection{Дип клиент}
Дип клиент это класс в JavaScript, находящийся в npm библиотеке
@deep-foundation/deeplinks. Предназначен для использования дипа
программно в JavaScript среде

\subsubsection{Вставка связей}

\paragraph{Примеры}

\subparagraph{Вставка связи с типом 1}
\begin{lstlisting}
await deep.insert({
  type_id: 1,
});
\end{lstlisting}

\subparagraph{Вставка связи с типом \hyperlink{type.Def}{Type}}
\begin{lstlisting}
await deep.insert({
  type_id: await deep.id("@deep-foundation/core", "Type"),
});
\end{lstlisting}

\subparagraph{Вставка связи с типом Reply из пакета messenger}
\begin{lstlisting}
await deep.insert({
  type_id: await deep.id("messenger", "Reply"),
  from_id: await deep.id("MyPackageName", "MyMessage"),
  to_id: await deep.id("MyPackageName", "MyConversation"),
});
\end{lstlisting}

\subparagraph{Вставка строкового значения для связи 100}
\begin{lstlisting}
await deep.insert(
  {
    link_id: 100,
    value: "MyValue",
  },
  {
    table: "strings",
  }
);
\end{lstlisting}

\subsubsection{Получение связей}

\paragraph{Примеры}

\subparagraph{Получение связи с типом 1}
\begin{lstlisting}
await deep.select({
  type_id: 1,
});
\end{lstlisting}

\subparagraph{Получение связи с типом \hyperlink{type.Def}{Type}}
\begin{lstlisting}
await deep.select({
  type_id: await deep.id("@deep-foundation/core", "Type"),
});
\end{lstlisting}

\subparagraph{Получение связи с типом Reply из пакета messenger}
\begin{lstlisting}
await deep.select({
  type_id: await deep.id("messenger", "Reply"),
  from_id: await deep.id("MyPackageName", "MyMessage"),
  to_id: await deep.id("MyPackageName", "MyConversation"),
});
\end{lstlisting}

\subparagraph{Получение строкового значения для связи 100}
\begin{lstlisting}
await deep.select(
  {
    link_id: 100,
  },
  {
    table: "strings",
  }
);
\end{lstlisting}

\subsubsection{Обновление связей}

Примечание: используйте любое другое ограничение, например, \{from: 100, to:
150\}.

\paragraph{Примеры}

\subparagraph{Обновление начала и конца}
\begin{lstlisting}
await deep.update(
  {
    id: 1,
  },
  {
    from_id: 5,
    to_id: 5
  }
);
\end{lstlisting}

\subparagraph{Обновление строкового значения}
\begin{lstlisting}
await deep.update(
  {
    link_id: 1,
  },
  {
    value: "MyNewValue",
  },
  {
    table: "strings",
  }
);
\end{lstlisting}

\subsubsection{Удаление связей}

\paragraph{Примеры \\}

Удаление связи с типом 1

\begin{lstlisting}
await deep.delete({
  type_id: 1,
});
\end{lstlisting}

Удаление связи с типом \hyperlink{type.Def}{Type}

\begin{lstlisting}
await deep.delete({
  type_id: await deep.id("@deep-foundation/core", "Type"),
});
\end{lstlisting}

Удаление связи с определённым типом, началом, концом
\begin{lstlisting}
await deep.delete({
  type_id: 5,
  from_id: 10,
  to_id: 15,
});
\end{lstlisting}

Удаление строкового значения для связи 100
\begin{lstlisting}
await deep.delete(
  {
    link_id: 100,
  },
  {
    table: "strings",
  }
);
\end{lstlisting}

\subsubsection{deep.id}
У Дип Клиента есть метод id, который позволяет получить идентификатор связи,
используя название пакета/пользователя и название связи
\paragraph{Примеры}
\subparagraph{Получение связи MyType из пакета MyPackage}
\begin{lstlisting}
  await deep.id("MyPackage", "MyType");
\end{lstlisting}

\subparagraph{Получение пакета MyPackage}
\begin{lstlisting}
  await deep.id("MyPackage");
\end{lstlisting}

\subparagraph{Получение связи C, которая вложена в B, которая вложена в A}
\begin{lstlisting}
  await deep.id("A", "B", "C");
\end{lstlisting}

\subsection{Таблицы}
Deep использует различные таблицы, такие как links (для хранения связей) и
numbers, strings, objects (для хранения значений привязанных к связям).

\begin{itemize}
  \item \textbf{links} - связи
  \item \textbf{strings} - строковые значения
  \item \textbf{numbers} - числовые значения
  \item \textbf{objects} - объектные значения (фактически JSON, поэтому можно
        вставлять числа/строки в таблицу objects, а не только объекты)
  \item \textbf{selectors} - селекторы
  \item \textbf{mp} - материализация пути связей
  \item \textbf{tree} - деревья
  \item \textbf{\texttt{promise\_links}} - для очереди выполнения обработчиков
  \item \textbf{\texttt{handlers}} - обработчики
  \item \textbf{\texttt{reserved}} - зарезервированные связи
  \item \textbf{\texttt{bool\_exp}} - используется для компиляции
        дополнительных условий в селекторах
  \item \textbf{\texttt{can}} - позволяет ответить быстро на вопрос есть ли у
        той или иной связи прав
  \item \textbf{\texttt{files}} - файлы
\end{itemize}

\subsubsection{Часто задаваемые вопросы}
\paragraph{Как дать название связи?}
\hypertarget{FAQ.HowToSetName}{Что бы дать название связи}, нужно изменить
значение \hyperlink{Contain.Def}{Contain} связи, которая указывает на вашу
связь. \\
\textbf{Исключения:}
\begin{itemize}
  \item \hyperlink{Package.Def}{Package}
  \item \hyperlink{Package.Def}{User}
\end{itemize}
\paragraph{Как вставить связь без начала и
  конца?}\hypertarget{FAQ.HowToInsertLinkWithoutFromAndTo}{}
\subparagraph{В DeepCase}
При \hyperlink{DeepCase.InsertLink.Def}{вставке связи} нажмите в пустом месте
\subparagraph{Программно}
\begin{verbatim}
await deep.insert({
  type_id: await deep.id("@deep-foundation/core", "Type"), // from_id и to_id не указаны
});
\end{verbatim}

\section{Часть регистрации изменений}

\begin{table}[h]
  \centering
  \caption{Часть регистрации изменений}
  \begin{tabular}{|c|p{8cm}|c|}
    \hline
    \textbf{№} & \textbf{Изменение}     & \textbf{Дата} \\
    \hline
    1          & Добавлена документация & 21.11.2023    \\
    \hline
  \end{tabular}
\end{table}

\end{document}
