\subsubsection{Часто задаваемые вопросы}
\paragraph{Как дать название связи?}
\hypertarget{FAQ.HowToSetName}{Что бы дать название связи}, нужно изменить
значение \hyperlink{Core.Contain.Description}{Contain} связи, которая указывает
на вашу
связь. \\
\textbf{Исключения:}
\begin{itemize}
      \item \hyperlink{Core.Package.Description}{Package}
      \item \hyperlink{Core.Package.Description}{User}
\end{itemize}
\paragraph{Как вставить связь без начала и
      конца?}\hypertarget{FAQ.HowToInsertLinkWithoutFromAndTo}{}
\subparagraph{В DeepCase}
При \hyperlink{DeepCase.InsertLink.Description}{вставке связи} нажмите в пустом
месте
\subparagraph{Программно}
\begin{verbatim}
await deep.insert({
  type_id: await deep.id("@deep-foundation/core", "Type"), // from_id и to_id не указаны
});
\end{verbatim}
\paragraph{Как вставить связь с началом и
      концом?}\hypertarget{FAQ.HowToInsertLinkWithFromAndTo}{}
\subparagraph{В DeepCase}
При \hyperlink{DeepCase.InsertLink.Description}{вставке связи} нажмите на
начале, и не отпуская протяните линию до конца
\subparagraph{Программно}
\begin{verbatim}
await deep.insert({
  type_id: await deep.id("@deep-foundation/core", "Type"),
  from_id: await deep.id("@deep-foundation/core", "Type"),
  to_id: await deep.id("@deep-foundation/core", "Type"),
});
\end{verbatim}
\paragraph{Почему при поиске связи мы видим две связи с одним и тем же именем?}
Одна из связей обозначена иконкой папки. Это связь типа \hyperlink{Contain}{Core.Contain.Description}, а другая связь - скорее всего именно та, что вам нужна. Вы можете замететь, что у связи типа \hyperlink{Contain}{Core.Contain.Description} конец (стрелка вправо) указывает на связь, которая вам нужна
\paragraph{Как создать новый docker isolation provider?}
\begin{itemize}
      \item Сделайте fork репозитория https://github.com/konard/python-docker-isolation-provider, измените код по своему усмотрению
      \item Измените название во всех файлах
      \item Установите deep пакет @konard/python-docker-isolation-provider
      \item Измените название
      \item Найдите связь типа DockerIsolationProvider и измените её значение на имя вашего docker образа, который генерируется в Github Actions вашего форка
\end{itemize}
\paragraph{Как выключить обработчик?}
Обработчик может существовать, но не выполняться. Выполнение контролируется связями, название которых начинается словом Handle. К примеру, если ваш обработчик обрабатывает вставку, то вам нужно удалить связь типа \hyperlink{HandleInsert}{Core.HandleInsert.Description}, связанный с вашим обработчиком. Это так же можно сделать в DeepCase в редакторе обработчиков
\paragraph{Как удалить связь и всё, что в ней содержится?}
\begin{verbatim}
const linkId = // Your Link Id
await deep.delete({
    up: {
        "tree_id": {
          "_id": [
            "@deep-foundation/core",
            "containTree"
          ]
        },
      parent_id: linkId
    }
  })
\end{verbatim}
Заметка: связи, как-либо связанные с удалёнными связями - не будут удалены. Для рекурсивного удаления рекомендуется использовать пакет \href{@lemeho/garbage-collection}{https://www.npmjs.com/package/@lemeho/garbage-collection}
\paragraph{Как удалить все Contain связи, которые ведут к удалённым связям?}
\begin{verbatim}
const {data: containLinks} = await deep.select({
    type_id: {
        _id: ["@deep-foundation/core", "Contain"]
    }
}, {returning: `${deep.selectReturning} to {${deep.selectReturning}}`})


const containLinkIdsToDelete = [];
for(const containLink of containLinks) {
    if(!containLink.to){
        containLinkIdsToDelete.push(containLink.id)
    }
}
await deep.delete({
    id: {
        _in: containLinkIdsToDelete
    }
})
\end{verbatim}
\paragraph{Как удалить все связи, которые используют типы из определённого пакета?}
\begin{verbatim}
const PACKAGE_NAME = // Your Package Name

await deep.delete({
    up: {
      parent: {
        type_id: {
          _id: ["@deep-foundation/core", "Contain"]
        },
        from_id: deep.linkId,
        to: {
          type: {
            in: {
              type_id: {
                _id: ["@deep-foundation/core", "Contain"]
              },
              from: { string: { value: { _eq: PACKAGE_NAME  } } }
            }
          }
        }
      }
    }
  })
\end{verbatim}
\paragraph{Как запросить все связи определённого пакета в DeepCase?}
Используйте вот такой Query:
\begin{verbatim}
{
  up: {
    parent: {
      id: {
        _id: ["YOUR_PACKAGE_NAME"]
      }
    },
    tree_id: {
      _id: ["@deep-foundation/core", "containTree"]
    }
  }
}
\end{verbatim}
\paragraph{Почему обновление связи не работает?}
Если у вашей связи не существовало значение до обновления, для начала вам нужно вставить значение, и лишь затем, после того, как у связи есть значение - вы можете его обновлять.
Пример вставки значения:
\begin{verbatim}
const value = VALUE /* "Value" / 123 / {property: value}  */;
const linkId = LINK_ID;
await deep.insert(
  {
    link_id: linkId, value: value 
  },
  {
    table: `${typeof value}s`
  }
);
\end{verbatim}
\paragraph{Как найти связь, значение которой содержит определённое значение?}
\begin{verbatim}
const value = PLACEHOLDER;
await deep.select({
  [typeof value]: {
    value: {
      _contains: value,
    },
  },
});
\end{verbatim}